{"pages":[{"url":"http://www.vmetu.com/blog/ji-suan-ji-tu-xing-shu-xue-zhong-ju-zhen-xue-xi-bi-ji.html","text":"计算机图形数学基础学习笔记 在游戏编程过程中，如果要操作一个物体，我们会使用各种矩阵。下面来说一下这些矩阵是如何起作用的。 矩阵与坐标变换 在图像的绘制过程中，矩阵主要是用来进行坐标变换。我们先来看下面的推导。 要得到任意 坐标系1 中的某个点[a, b, c]，可以让原点先在x轴位移[a, 0, 0], 再在y轴上位移[0, b, 0]，最后在z轴上位移[0, 0, c]。将这三个方向的单位向量定义为 \\(p,q,r\\) , 可以得到推导中的(1)。 p,q,r是 坐标系2 中的某个向量，如推导中的(2) 计算后得到推导结果(4)，该结果就是 坐标系1 中的向量[a, b, c]在 坐标系2 中的表示 从最终的结果可以看出，将一个 坐标系1 中的向量变换到 坐标系2 中，只需要 右乘一个矩阵 即可。再看这个矩阵的内容，我们发现它的每一行就是 坐标系1 中的坐标轴方向的 单位向量 在 坐标系2 中的表示。 在二维笛卡尔坐标系下来看一下实例： 对于 物体坐标系 ，它的坐标轴的单位向量在 世界坐标系 中分别为：p=[2, 1], q=[-1, 2]： 那么对于物体坐标系中的某个点[1, 1]，变换到世界坐标系中为： 我们发现，从 物体坐标系 到 世界坐标系 的变换，是 物体坐标系 进行了 缩小 ，和 顺时针旋转 ， 但对于绘制出来的图像对于 世界坐标系 却是 放大 和 逆时针旋转 。在计算机绘制图形的时候，就是通过变换坐标系来进行图像的 缩放 和 旋转 的。 矩阵变换的应用 计算时，可以通过预先得出的变换矩阵来使流程简化。下面列一下各种变换矩阵。 缩放 二维与三维的缩放矩阵： 其中n为缩放方向，k为缩放因子。 旋转 二维坐标系中的绕圆心旋转和三维坐标系中绕某个向量旋转 正交投影 投影其实就是缩放。向某个平面投影，就是物体在该平面的法向量上的缩放为0。 镜像 镜像也是缩放。物体对于某个平面的镜像，就是该物品在平面法向量上的缩放为-1。例如在Unity2D中，如果将某个精灵的轴的缩放设为-1，那么会得到一个镜像精灵。 平移与齐次坐标 从上面的内容可知，将某一个向量平移，可以加上一个矩阵；将一个物体缩放或旋转，可以右乘一个矩阵： 其中M1是缩放旋转矩阵，M2是位移矩阵。如果经过多次这样的变换的话，会产生很多的代数项，齐次坐标就是用来解决这个问题的。 所谓齐次坐标就是用n+1个分量来表示n维坐标。例如：二维平面上的点 \\(A(x , y)\\) 用齐次坐标表示为 \\((h_x , h_y , h)\\) ；三维空间中的点 \\(B(x , y , z)\\) 用齐次坐标表示为 \\((h_x , h_y , h_z , h)\\) 。一个向量的齐次表示并不是唯一的，齐次坐标中的h取不同值表示的都是同一个点，比如(8 , 4 , 2)、(4 , 2 , 1)表示的都是二维平面上的点(4 , 2)。下面来看一个等式： 可以看出，一个点的位移，可以用齐次坐标的右乘来表示。 矩阵的缺点 不直观 数据冗余 大量矩阵相乘容易产生坏数据 欧拉角 在三维坐标系中，要转动某个物体，可以通过依次绕其各个轴旋转来实现。那么表示一个物体的方位，就可以通过这三个角来表示。 欧拉角表示的是物体的最终方位而不是旋转过程。例如我们说将一个物体旋转到(ψ, θ, φ)，这个方位是相对于物体 未旋转 时的角度，而 不是 将当前物体绕z轴旋转ψ， 绕x轴旋转θ， 绕y轴旋转φ。 万向节运动 因为用欧拉角表示方位与旋转的次序无关。unity中默认的是z-x-y，这样的次序就导致了z轴的旋转会影响x,y轴的旋转，x轴的旋转会影响y轴的旋转。 这样的旋转类似于万向节的运动。 万向锁 假设物体按heading-pitch-bank的方式旋转，例如在下面的 示例 中，绿色圈代表y轴的旋转，红色圈代表x轴的旋转，蓝色轴代表z轴的旋转。初始状态如下图： 当绕x轴旋转90度时，发现此时的z轴和以前y轴重合了。 这就意味着，最开始的y轴旋转和此时的z轴旋转是等效的，z轴的旋转可以通过y轴的旋转来实现，可以被认为是无效的。那么欧拉角就损失了一个维度。例如在Unity 3D中： 方位一致 插值计算 欧拉角对计算物体旋转差值产生影响。以Unity3D为例。 假如一个物体的初始方位为（90， 0， 0）， 要旋转到（0， 90， 90） 直观上看，就是将HelloWord立起来。但却有三个坐标轴做了旋转，通过分析其中的插值可以看到，它运动的路径和我们期望的路径并不一样。 计算错误的原因：因为是以万向节的形式旋转，物体旋转到某个位置，有可能需要同时旋转两个或三个坐标轴。此时真正的球面差值和欧拉角的差值不同。旋转依赖的参数太多。 复数与旋转 要解决差值问题，还是要减少旋转依赖的参数。但矩阵的数据太冗余，好在数学家们发现如下规律: 对于复数： \\( p = x + yi\\) \\( q = cos\\theta + i sin\\theta\\) \\( pq = (x + yi)(cos\\theta + isin\\theta) = (xcos\\theta - ysin\\theta) + (xsin\\theta+ ycos\\theta)i\\) 这对于上面的旋转矩阵是不是很像？只要将复数的实部和虚部看做坐标轴，那么 p 可以看做一个向量，pq就可以看p成旋转θ角之后的向量。 四元数 相对于二维坐标中的复数，数学家还定义了三维坐标中的四元数： \\(p = w + xi + yj + zk\\) 其中： \\(i&#94;2 = j&#94;2 = k&#94;2 = -1\\) \\(ij = k, ji = -k\\) \\(jk = i, kj = -i\\) \\(ki = j, ik = -j\\) 设四元数： \\( q = [cos(\\theta /2), nsin(\\theta/2)] = [cos(\\theta/2), ({n}_{x}sin(\\theta/2), {n}_{y}sin(\\theta/2), {n}_{z}sin(\\theta/2))]\\) 对于任意四元数： \\( p = [w, (x, y, z)]\\) 那么对于等式： \\( p' = qpq&#94;{-1} = [cos(\\theta /2), nsin(\\theta/2)][w, (x, y, z)][cos(\\theta /2), -nsin(\\theta/2)]\\) 展开后可以得到类似于三维旋转矩阵的东西。这说明四元数可以用在物体的旋转计算中。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"计算机图像","title":"计算机图形数学中矩阵学习笔记"},{"url":"http://www.vmetu.com/blog/pythondai-ma-duan.html","text":"下面总结一些日常Python代码段 遍历文件夹 import os def getAllFile ( dirPath ): ret = [] allsub = os . listdir ( dirPath ) for sub in allsub : subPath = \" %s / %s \" % ( dirPath , sub ) if os . path . isfile ( subPath ): ret . append ( subPath ) if os . path . isdir ( subPath ): ret . extend ( getAllFile ( subPath )) return ret 打zip包 import zipfile , os zipPakFile = zipfile . ZipFile ( zipflieName , 'w' , zipfile . ZIP_DEFLATED ) for item in fileList : zipPakFile . write ( item ) zipPakFile . close () 删除文件夹 import shutil shutil . rmtree ( dirPath , True ) #True表示即使为空也强制删除，如果不加True, 只能删除空文件夹 创建文件夹 if not os.path.isdir(dir): os.makedirs(dir) #makedirs和mkdir的区别是，如果父目录不存在，makedirs会创建父目录，而mkdir不会","tags":"Python","title":"python代码段"},{"url":"http://www.vmetu.com/blog/glscissorhan-shu.html","text":"glScissor函数用来剪裁一个绘制区域，比如只要展示纹理的一部分，示例： void myDisplay(void) { glEnable(GL_SCISSOR_TEST); glScissor(50, 50, 50, 50); glClear(GL_COLOR_BUFFER_BIT); glRectf(0, 0, 200, 200); glFlush(); glDisable(GL_SCISSOR_TEST); } 这里本来要绘制一个(0,0)位置开始宽高都为200的矩形，加上glScissor语句后，只绘制从(50, 50)开始宽高都为50的这部分区域。","tags":"OpenGL","title":"glScissor函数"},{"url":"http://www.vmetu.com/blog/vszhong-error-c2001de-jie-jue-ban-fa.html","text":"今天遇到一个问题，在VS2010工程中，出现中文字符串时，出现了如下错误： error C2001 : newline in constant error C2143 : syntax error : missing ')' before '}' error C2143 : syntax error : missing ';' before '}' 产生原因可以参照： http://blog.163.com/zhaowenjia1989@126/blog/static/1094985792010224153119/ 一些结局办法可以参照： http://www.cnblogs.com/kuliuheng/p/3397796.html 还有一个简单的办法： 1. 在VS中打开该代码文件。 2. 选择VS菜单栏中 File -> Advanced Save Options 3. 选择中文的编码： 4. 重新编译，OK","tags":"C++","title":"VS中Error C2001的解决办法"},{"url":"http://www.vmetu.com/blog/mathfxiang-guan-han-shu.html","text":"这里对Mathf相关函数做一个简要说明，抄的。 Mathf.Abs绝对值## 计算并返回指定参数 f 绝对值。 Mathf.Acos反余弦 static function Acos (f : float) : float 以弧度为单位计算并返回参数 f 中指定的数字的反余弦值。 Mathf.Approximately近似 static function Approximately (a : float, b: float) : bool 比较两个浮点数值，看它们是否非常接近, 由于浮点数值不精确，不建议使用等于来比较它们。例如，1.0==10.0/10.0也许不会返回true。 public class example : MonoBehaviour { publicvoid Awake() { if(Mathf.Approximately(1.0F, 10.0F / 10.0F)) print(\"same\"); } } Mathf.Asin反正弦 static function Asin (f : float) : float 以弧度为单位计算并返回参数 f 中指定的数字的反正弦值。 Mathf.Atan2反正切 static function Atan2 (y : float, x :float) : float 以弧度为单位计算并返回 y/x 的反正切值。返回值表示相对直角三角形对角的角，其中 x 是临边边长，而 y 是对边边长。 返回值是在x轴和一个二维向量开始于0个结束在(x,y)处之间的角。 public class example : MonoBehaviour { publicTransform target; voidUpdate() { Vector3relative = transform.InverseTransformPoint(target.position); floatangle = Mathf.Atan2(relative.x, relative.z) * Mathf.Rad2Deg; transform.Rotate(0,angle, 0); } } Mathf.Atan反正切 static function Atan (f : float) :float 计算并返回参数 f 中指定的数字的反正切值。返回值介于负二分之 pi 与正二分之 pi 之间。 Mathf.CeilToInt最小整数 static function CeilToInt (f : float) : int 返回最小的整数大于或等于f。 Mathf.Ceil上限值 static function Ceil (f : float) : float 返回 f 指定数字或表达式的上限值。数字的上限值是大于等于该数字的最接近的整数。 Mathf.Clamp01 static function Clamp01 (value : float) :float 限制value在0,1之间并返回value。如果value小于0，返回0。如果value大于1,返回1，否则返回value 。 Mathf.Clamp static function Clamp (value : float, min :float, max : float) : float 限制value的值在min和max之间， 如果value小于min，返回min。 如果value大于max，返回max，否则返回value static function Clamp (value : int, min :int, max : int) : int 限制value的值在min和max之间，并返回value。 Mathf.ClosestPowerOfTwo最近的二次方 static function ClosestPowerOfTwo (value :int) : int 返回距离value最近的2的次方数。 Mathf.Cos余弦 static function Cos (f : float) : float 返回由参数 f 指定的角的余弦值（介于 -1.0 与 1.0 之间的值）。 Mathf.Deg2Rad度转弧度 static var Deg2Rad : float 度到弧度的转化常量。（只读） 这等于(PI * 2) / 360。 Mathf.Mathf.Rad2Deg 弧度转度 static var Rad2Deg : float 弧度到度的转化常量。（只读） 这等于 360 / (PI * 2)。 Mathf.DeltaAngle增量角 static function DeltaAngle (current :float, target : float) : float 计算给定的两个角之间最短的差异。 // Prints 90 Debug.Log(Mathf.DeltaAngle(1080,90)); Mathf.Epsilon小正数 static var Epsilon : float 一个很小的浮点数值。（只读） 最小的浮点值，不同于0。 以下规则： - anyValue + Epsilon = anyValue - anyValue - Epsilon = anyValue - 0 + Epsilon = Epsilon - 0 - Epsilon = -Epsilon 一个在任意数和Epsilon的之间值将导致在任意数发生截断误差。 public class example : MonoBehaviour { boolisEqual(float a, float b) { if(a >= b - Mathf.Epsilon && a <= b + Mathf.Epsilon) returntrue; else returnfalse; } } Mathf.Exp指数 static function Exp (power : float) : float 返回 e 的 power 次方的值。 Mathf.FloorToInt最大整数 static function FloorToInt (f : float) :int 返回最大的整数，小于或等于f。 Mathf.Floor下限值 static function Floor (f : float) : float 返回参数 f 中指定的数字或表达式的下限值。下限值是小于等于指定数字或表达式的最接近的整数。 Mathf.Infinity正无穷 static var Infinity : float 表示正无穷，也就是无穷大，∞ （只读） Mathf.InverseLerp反插值 计算两个值之间的Lerp参数。也就是value在from和to之间的比例值。 //现在参数是3/5 float parameter =Mathf.InverseLerp(walkSpeed, runSpeed, speed); Mathf.IsPowerOfTwo是否2的幂 static function IsPowerOfTwo (value : int): bool 如果该值是2的幂，返回true。 // prints false Debug.Log(Mathf.IsPowerOfTwo(7)); // prints true Debug.Log(Mathf.IsPowerOfTwo(32)); Mathf.LerpAngle插值角度 static function LerpAngle (a : float, b :float, t : float) : float 和Lerp的原理一样，当他们环绕360度确保插值正确。 a和b是代表度数。 public class example : MonoBehaviour { publicfloat minAngle = 0.0F; publicfloat maxAngle = 90.0F; voidUpdate() { floatangle = Mathf.LerpAngle(minAngle, maxAngle, Time.time); transform.eulerAngles= new Vector3(0, angle, 0); } } Mathf.Lerp插值 static function Lerp (from : float, to :float, t : float) : float 基于浮点数t返回a到b之间的插值，t限制在0～1之间。 当t = 0返回from，当t = 1 返回to。当t = 0.5 返回from和to的平均值。 Mathf.Log10基数10的对数 static function Log10 (f : float) : float 返回f的对数，基数为10。 Mathf.Log对数 static function Log (f : float, p : float): float 返回参数 f 的对数。 // logarithm of 6 in base 2 //以2为底6的对数 // prints 2.584963 print(Mathf.Log(6, 2)); Mathf.Max最大值 static function Max (a : float, b : float): float static function Max (params values :float[]) : float 返回两个或更多值中最大的值。 Mathf.Min最小值 static function Min (a : float, b : float): float static function Min (params values :float[]) : float 返回两个或更多值中最小的值。 Mathf.MoveTowardsAngle移动角 static function MoveTowardsAngle (current :float, target : float, maxDelta : float) : float 像MoveTowards,但是当它们环绕360度确保插值正确。 变量current和target是作为度数。为优化原因，maxDelta负值的不被支持，可能引起振荡。从target角推开current，添加180度角代替。 Mathf.MoveTowards移向 static function MoveTowards (current :float, target : float, maxDelta : float) : float 改变一个当前值向目标值靠近。 这实际上和 Mathf.Lerp相同，而是该函数将确保我们的速度不会超过maxDelta。maxDelta为负值将目标从推离。 Mathf.NegativeInfinity负无穷 static var NegativeInfinity : float 表示负无穷，也就是无穷小，-∞（只读） Mathf.NextPowerOfTwo下个2的幂 Mathf.PingPong乒乓 static function PingPong (t : float, length: float) : float 0到length之间往返。t值永远不会大于length的值，也永远不会小于0。 The returned value will move back and forthbetween 0 and length. 返回值将在0和length之间来回移动。 Mathf.PI圆周率 static var PI : float PI（读pai）的值，也就是圆周率（π）的值3.14159265358979323846...（只读） Mathf.Pow次方 static function Pow (f : float, p : float): float 计算并返回 f 的 p 次方。 Mathf.Repeat重复 static function Repeat (t : float, length :float) : float 循环数值t，0到length之间。t值永远不会大于length的值，也永远不会小于0。 这是类似于模运算符，但可以使用浮点数。 public class example : MonoBehaviour { voidUpdate() { transform.position= new Vector3(Mathf.Repeat(Time.time, 3), transform.position.y,transform.position.z); } } Mathf.RoundToInt四舍五入到整数 static function RoundToInt (f : float) :int 返回 f 指定的值四舍五入到最近的整数。 如果数字末尾是.5，因此它是在两个整数中间，不管是偶数或是奇数，将返回偶数。 Mathf.Round四舍五入 static function Round (f : float) : float 返回浮点数 f 进行四舍五入最接近的整数。 如果数字末尾是.5，因此它是在两个整数中间，不管是偶数或是奇数，将返回偶数。 Mathf.Sign符号 static function Sign (f : float) : float 返回 f 的符号。 当 f 为正或为0返回1，为负返回-1。 Mathf.Sin正弦 static function Sin (f : float) : float 计算并返回以弧度为单位指定的角 f 的正弦值。 Mathf.SmoothDampAngle平滑阻尼角度 static function SmoothDampAngle (current :float, target : float, ref currentVelocity : float, smoothTime : float,maxSpeed : float = Mathf.Infinity, deltaTime : float = Time.deltaTime) : float 参数 current : 当前的位置。 target : 我们试图达到的位置。 currentVelocity : 当前速度，这个值在你访问这个函数的时候会被随时修改。 smoothTime : 要到达目标位置的近似时间，实际到达目标时要快一些。 maxSpeed : 可选参数，允许你限制的最大速度。 deltaTime : 上次调用该函数到现在的时间。缺省为Time.deltaTime。 随着时间的推移逐渐改变一个给定的角度到期望的角度。 这个值通过一些弹簧减震器类似的功能被平滑。这个函数可以用来平滑任何一种值，位置，颜色，标量。最常见的是平滑一个跟随摄像机。 //一个简单的平滑跟随摄像机 //跟随目标的朝向 public class example : MonoBehaviour { publicTransform target; publicfloat smooth = 0.3F; publicfloat distance = 5.0F; privatefloat yVelocity = 0.0F; voidUpdate() { //从目前的y角度变换到目标y角度 floatyAngle = Mathf.SmoothDampAngle(transform.eulerAngles.y, target.eulerAngles.y,ref yVelocity, smooth); //target的位置 Vector3position = target.position; //然后，新角度之后的距离偏移 position+= Quaternion.Euler(0, yAngle, 0) * new Vector3(0, 0, -distance); //应用位置 transform.position= position; //看向目标 transform.LookAt(target); } } Mathf.SmoothDamp平滑阻尼 static function SmoothDamp (current :float, target : float, ref currentVelocity : float, smoothTime : float,maxSpeed : float = Mathf.Infinity, deltaTime : float = Time.deltaTime) : float 参数 current : 当前的位置。 target : 我们试图达到的位置。 currentVelocity : 当前速度，这个值在你访问这个函数的时候会被随时修改。 smoothTime : 要到达目标位置的近似时间，实际到达目标时要快一些。 maxSpeed : 可选参数，允许你限制的最大速度。 deltaTime : 上次调用该函数到现在的时间。缺省为Time.deltaTime。 描述 随着时间的推移逐渐改变一个值到期望值。 这个值就像被一个不会崩溃的弹簧减振器一样被平滑。这个函数可以用来平滑任何类型的值，位置，颜色，标量。 public class example : MonoBehaviour { publicTransform target; publicfloat smoothTime = 0.3F; privatefloat yVelocity = 0.0F; voidUpdate() { floatnewPosition = Mathf.SmoothDamp(transform.position.y, target.position.y, refyVelocity, smoothTime); transform.position= new Vector3(transform.position.x, newPosition, transform.position.z); } } Mathf.SmoothStep平滑插值 static function SmoothStep (from : float,to : float, t : float) : float 和lerp类似，在最小和最大值之间的插值，并在限制处渐入渐出。 public class example : MonoBehaviour { publicfloat minimum = 10.0F; publicfloat maximum = 20.0F; voidUpdate() { transform.position= new Vector3(Mathf.SmoothStep(minimum, maximum, Time.time), 0, 0); } } Mathf.Sqrt平方根 static function Sqrt (f : float) : float 计算并返回 f 的平方根。 Mathf.Tan正切 static function Tan (f : float) : float 计算并返回以弧度为单位 f 指定角度的正切值。","tags":"Unity","title":"Mathf相关函数"},{"url":"http://www.vmetu.com/blog/unity2dzheng-dong-hua-shi-xian-de-liang-chong-fang-shi.html","text":"在游戏制作过程中，经常用到帧动画，这里介绍两种实现帧动画的方式 源材料准备 序列帧所用到的图片： 生成这些序列帧所用到的资源可以参考： http://www.raywenderlich.com/61532/unity-2d-tutorial-getting-started 1. 脚本方式实现 脚本实现的方式在上面的链接中有介绍，这里把列出源码： using UnityEngine; using System.Collections; public class Zombie : MonoBehaviour { public Sprite[] m_sprits; public int m_frameRate; ／／帧率 float m_frameTime; SpriteRenderer m_spriteRenderer; // Use this for initialization void Start () { m_frameTime = 1.0f / (float)m_frameRate; m_spriteRenderer = GetComponent<SpriteRenderer> (); } // Update is called once per frame void Update () { m_frameTime -= Time.deltaTime; if (m_frameTime < 0.0f) { int index = 0; for (; index < m_sprits.Length; index ++ ) { if (m_sprits[index] == m_spriteRenderer.sprite) { break; } } index = (index + 1) % m_sprits.Length; m_spriteRenderer.sprite = m_sprits[index]; m_frameTime = 1.0f / (float)m_frameRate; } } } 2.编辑器实现 帧动画也可以由Unity的动画编辑器来实现，实现方式如下。 打开动画编辑器 先在场景中以序列帧的第一帧创建一个精灵，选中它，然后通过快捷键Ctrl + 6 或者菜单中的 Window -> Animation打开动画编辑器。在弹出窗口的左上角点击 Add Property , 会弹出一个让你保存动画的界面，如图： 输入一个名字将其保存起来。 根据上面程序实现的方法，我们知道绘制精灵是通过SpriteRender来实现的, 所以在动画编辑器中可以增加一个SpriteRender属性： 之后就可以将序列帧拖入动画编辑器中： 加好之后，点击左上角的三角符号，就可以发现Unity编辑器中的僵尸动起来了。","tags":"Unity","title":"Unity2D帧动画实现的两种方式"},{"url":"http://www.vmetu.com/blog/pelicanan-zhuang-guo-cheng.html","text":"今天安装了Pelican，下面来说下过程和遇到的问题 安装Python，因为在Mac下，省掉这一步 安装pip( 下载地址 ), 解压后运行： python setup.py install 安装 安装pelican， 运行 pip install pelican 安装markdown， 运行 pip install markdown 启动pelican创建工程，pelican－quickstart, 此时有可能出现如下错误： Traceback ( most recent call last ): File \"/usr/local/bin/pelican-quickstart\" , line 7 , in < module > from pelican.tools.pelican_quickstart import main File \"/Library/Python/2.7/site-packages/pelican/__init__.py\" , line 20 , in < module > from pelican.generators import ( ArticlesGenerator , PagesGenerator , File \"/Library/Python/2.7/site-packages/pelican/generators.py\" , line 22 , in < module > from pelican.readers import Readers File \"/Library/Python/2.7/site-packages/pelican/readers.py\" , line 24 , in < module > from six.moves.html_parser import HTMLParser ImportError : No module named html_parser 这时只需要更改一下源文件即可： vim /Library/Python/2.7/site-packages/pelican/readers.py 。 将24行的： from six.moves.html_parser import HTMLParser 换成： from HTMLParser import HTMLParser 即可","tags":"Pelican","title":"Pelican安装过程"}]}